<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hermes (IBC Relayer CLI) Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Hermes (v0.11.1)</li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="relayer.html"><strong aria-hidden="true">1.1.</strong> What is Hermes?</a></li></ol></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="features/matrix.html"><strong aria-hidden="true">2.1.</strong> Feature matrix</a></li></ol></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pre_requisites.html"><strong aria-hidden="true">3.1.</strong> Pre-requisites</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="config.html"><strong aria-hidden="true">3.3.</strong> Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="telemetry.html"><strong aria-hidden="true">4.</strong> Telemetry</a></li><li class="chapter-item expanded "><a href="rest-api.html"><strong aria-hidden="true">5.</strong> REST API</a></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">6.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/index.html"><strong aria-hidden="true">6.1.</strong> Local chains</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/gaia.html"><strong aria-hidden="true">6.1.1.</strong> Install Gaia</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/start.html"><strong aria-hidden="true">6.1.2.</strong> Start the local chains</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/identifiers.html"><strong aria-hidden="true">6.1.3.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/index.html"><strong aria-hidden="true">6.1.4.</strong> Connect the chains using relay paths</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/create-new-path.html"><strong aria-hidden="true">6.1.4.1.</strong> Create a new path</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/relay-paths/multiple-paths.html"><strong aria-hidden="true">6.1.4.2.</strong> Relay packets on multiple paths</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/index.html"><strong aria-hidden="true">6.1.5.</strong> Connect the chains using raw transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/client.html"><strong aria-hidden="true">6.1.5.1.</strong> Configure clients</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/connection.html"><strong aria-hidden="true">6.1.5.2.</strong> Connection handshake</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/channel.html"><strong aria-hidden="true">6.1.5.3.</strong> Channel handshake</a></li><li class="chapter-item expanded "><a href="tutorials/local-chains/raw/packet.html"><strong aria-hidden="true">6.1.5.4.</strong> Relay packets</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="commands/index.html"><strong aria-hidden="true">7.</strong> Commands Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/global.html"><strong aria-hidden="true">7.1.</strong> Global options and JSON output</a></li><li class="chapter-item expanded "><a href="commands/keys/index.html"><strong aria-hidden="true">7.2.</strong> Keys</a></li><li class="chapter-item expanded "><a href="commands/config.html"><strong aria-hidden="true">7.3.</strong> Config</a></li><li class="chapter-item expanded "><a href="commands/path-setup/index.html"><strong aria-hidden="true">7.4.</strong> Path setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/path-setup/clients.html"><strong aria-hidden="true">7.4.1.</strong> Clients</a></li><li class="chapter-item expanded "><a href="commands/path-setup/connections.html"><strong aria-hidden="true">7.4.2.</strong> Connections</a></li><li class="chapter-item expanded "><a href="commands/path-setup/channels.html"><strong aria-hidden="true">7.4.3.</strong> Channels</a></li></ol></li><li class="chapter-item expanded "><a href="commands/relaying/index.html"><strong aria-hidden="true">7.5.</strong> Relaying</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/relaying/packets.html"><strong aria-hidden="true">7.5.1.</strong> Packet Messages</a></li><li class="chapter-item expanded "><a href="commands/relaying/handshakes.html"><strong aria-hidden="true">7.5.2.</strong> Handshake Messages</a></li></ol></li><li class="chapter-item expanded "><a href="commands/listen/index.html"><strong aria-hidden="true">7.6.</strong> Listen mode</a></li><li class="chapter-item expanded "><a href="commands/upgrade/index.html"><strong aria-hidden="true">7.7.</strong> Client upgrade</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/upgrade/test.html"><strong aria-hidden="true">7.7.1.</strong> Testing client upgrade</a></li></ol></li><li class="chapter-item expanded "><a href="commands/misbehaviour/index.html"><strong aria-hidden="true">7.8.</strong> Misbehaviour</a></li><li class="chapter-item expanded "><a href="commands/queries/index.html"><strong aria-hidden="true">7.9.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/queries/client.html"><strong aria-hidden="true">7.9.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="commands/queries/connection.html"><strong aria-hidden="true">7.9.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="commands/queries/channel.html"><strong aria-hidden="true">7.9.3.</strong> Channel</a></li><li class="chapter-item expanded "><a href="commands/queries/packet.html"><strong aria-hidden="true">7.9.4.</strong> Packet</a></li><li class="chapter-item expanded "><a href="commands/queries/tx.html"><strong aria-hidden="true">7.9.5.</strong> Tx</a></li></ol></li><li class="chapter-item expanded "><a href="commands/raw/index.html"><strong aria-hidden="true">7.10.</strong> Raw transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/raw/client.html"><strong aria-hidden="true">7.10.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="commands/raw/connection.html"><strong aria-hidden="true">7.10.2.</strong> Connection</a></li><li class="chapter-item expanded "><a href="commands/raw/channel-open.html"><strong aria-hidden="true">7.10.3.</strong> Channel Open</a></li><li class="chapter-item expanded "><a href="commands/raw/channel-close.html"><strong aria-hidden="true">7.10.4.</strong> Channel Close</a></li><li class="chapter-item expanded "><a href="commands/raw/packet.html"><strong aria-hidden="true">7.10.5.</strong> Packet</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="help.html"><strong aria-hidden="true">8.</strong> Help</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">9.</strong> Glossary</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hermes (IBC Relayer CLI) Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="hermes-guide-v0111"><a class="header" href="#hermes-guide-v0111">Hermes Guide (v0.11.1)</a></h1>
<p>Hermes is a an open-source Rust implementation of a relayer for the
<a href="https://ibcprotocol.org">Inter-Blockchain Communication protocol</a> (IBC).</p>
<p>This guide can help you setup, configure, and operate Hermes to transfer
packets between two or more IBC-enabled chains.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p><strong><a href="./relayer.html">What is Hermes</a></strong></p>
<ul>
<li>Explains what Hermes is about.</li>
</ul>
<p><strong><a href="./features.html">Features</a></strong></p>
<ul>
<li>This section discusses what features to expect from Hermes, as well as a
comparison between the Cosmos Go relayer and Hermes.</li>
</ul>
<p><strong><a href="./getting_started.html">Getting Started</a></strong></p>
<ul>
<li>The getting started section can help you setup, configure, and run Hermes.</li>
</ul>
<p><strong><a href="./tutorials/index.html">Tutorials</a></strong></p>
<ul>
<li>This section provides some tutorials on how to operate and test Hermes.</li>
</ul>
<p><strong><a href="./commands/index.html">Commands Reference</a></strong></p>
<ul>
<li>The commands let you interact with Hermes using its command line interface.</li>
</ul>
<p><strong><a href="./help.html">Help</a></strong></p>
<ul>
<li>This part provides guidelines regarding troubleshooting and general resources
for getting help.</li>
</ul>
<p><strong><a href="./glossary.html">Glossary</a></strong></p>
<ul>
<li>This section provides some definitions of terms used throughout the guide</li>
</ul>
<hr />
<p><strong>Other References and Useful Links:</strong></p>
<ul>
<li><a href="https://github.com/informalsystems/ibc-rs">Hermes Github repository</a>
— The official Github repository for Hermes.</li>
<li><a href="https://github.com/cosmos/ics">IBC Github repository</a>
<ul>
<li>The official repository for the Inter-blockchain protocol (IBC).</li>
</ul>
</li>
</ul>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>This project is undergoing heavy development, use at your own risk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-hermes"><a class="header" href="#what-is-hermes">What is Hermes?</a></h1>
<p>Hermes is a an open-source Rust implementation of a relayer for the
<a href="https://ibcprotocol.org">Inter-Blockchain Communication protocol</a> (IBC),
released under the <a href="https://crates.io/crates/ibc-relayer-cli">ibc-relayer-cli</a> crate.</p>
<p>The <strong>Inter-Blockchain Communication protocol</strong> is an end-to-end, connection-oriented,
state-ful protocol for reliable, ordered, and authenticated communication between modules
on separate distributed ledgers. <sup class="footnote-reference"><a href="#ibc">1</a></sup></p>
<p>An IBC <strong>relayer</strong> is an off-chain process responsible for relaying IBC datagrams between any two chains.
The way it does so is by scanning chain states, building transactions based on these states,
and submitting the transactions to the chains involved in the network.</p>
<p>The relayer is a central element in the IBC network architecture. This is because chain modules
in this architecture are not directly sending messages to each other over networking infrastructure,
but instead they create and store the data to be retrieved and used by a relayer to build the IBC datagrams.</p>
<p>We sometimes refer to Hermes as &quot;IBC Relayer CLI&quot;, to make it clear that this
is a relayer CLI (i.e., a binary) and distinguish from the relayer core library
(which is the crate called <a href="https://crates.io/crates/ibc-relayer"><code>ibc-relayer</code></a>).</p>
<p>Hermes is actively developed and maintained by <a href="https://informal.systems">Informal Systems</a> in the <a href="https://github.com/informalsystems/ibc-rs">ibc-rs</a> repository.</p>
<div class="footnote-definition" id="ibc"><sup class="footnote-definition-label">1</sup>
<p><a href="https://arxiv.org/pdf/2006.15918.pdf">The Interblockchain Communication Protocol: An Overview</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>This section includes a summary of the supported and planned features.
A feature matrix and comparison between the Rust and Go relayer implementations can be found in the <a href="./features/matrix.html">Feature Matrix</a></p>
<blockquote>
<p><strong>Cosmos SDK compatibility:</strong>
Hermes supports Cosmos SDK chains implementing the <a href="https://github.com/cosmos/ibc-go">IBC v1.1</a> protocol specification.
Cosmos SDK versions <code>0.41.3</code> to <code>0.44.x</code> are officially supported.
In case Hermes finds an incompatible SDK version, it will output a log warning.</p>
</blockquote>
<h2 id="supported-features"><a class="header" href="#supported-features">Supported Features</a></h2>
<ul>
<li>Basic features
<ul>
<li>create and update clients</li>
<li>refresh clients to prevent expiration</li>
<li>establish connections with new or existing clients</li>
<li>establish channels with new or existing connection</li>
<li>channel closing handshake</li>
<li>relay packets, acknowledgments, timeout and timeout-on-close packets, with zero or non-zero delay.</li>
<li>queries for all objects</li>
</ul>
</li>
<li>Packet relaying over:
<ul>
<li>multiple paths, for the chains in <code>config.toml</code></li>
</ul>
</li>
<li>Restart support
<ul>
<li>clear packets</li>
<li>resume channel handshake if configured to relay <code>all</code></li>
<li>resume connection handshake if configured to relay <code>all</code></li>
</ul>
</li>
<li>Client upgrade
<ul>
<li>upgrading clients after a counterparty chain has performed an upgrade for IBC breaking changes</li>
</ul>
</li>
<li>Packet delay:
<ul>
<li>establish path over non-zero delay connection</li>
<li>relay all packets with the specified delay</li>
</ul>
</li>
<li>Monitor and submit misbehaviour for clients
<ul>
<li>monitor client updates for misbehaviour (fork and BFT time violation)</li>
<li>submit misbehaviour evidence to the on-chain IBC client.</li>
</ul>
<blockquote>
<p>misbehaviour submission to full node not yet supported</p>
</blockquote>
</li>
<li>Individual commands that build and send transactions for:
<ul>
<li>creating and updating IBC Tendermint light clients</li>
<li>sending connection open handshake datagrams</li>
<li>sending channel open handshake datagrams</li>
<li>sending channel closing handshake datagrams</li>
<li>initiating a cross chain transfer (mainly for testing)</li>
<li>relaying sent packets, acknowledgments and timeouts</li>
<li>client upgrade</li>
</ul>
</li>
<li>Channel handshake for existing channel that is not in <code>Open</code> state</li>
<li>Connection handshake for existing connection that is not in <code>Open</code> state</li>
<li>Telemetry support</li>
</ul>
<h2 id="upcoming--unsupported-features"><a class="header" href="#upcoming--unsupported-features">Upcoming / Unsupported Features</a></h2>
<p>Planned features:</p>
<ul>
<li>Full Passive mode: relay from all IBC events
<ul>
<li>Connection handshake for existing connection that is not in <code>Open</code> state</li>
</ul>
</li>
<li>Relayer support for management application (add RPC server)</li>
<li>Dynamic configuration management</li>
</ul>
<p>Not planned:</p>
<ul>
<li>Relayer management application</li>
<li>Create clients with user chosen parameters (such as UpgradePath)</li>
<li>Use IBC light clients other than Tendermint such as Solo Machine</li>
<li>Support non cosmos-SDK chains</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-matrix"><a class="header" href="#feature-matrix">Feature Matrix</a></h1>
<p>This section gives more details about the features and implementation status 
of Hermes in comparison with the <a href="https://github.com/cosmos/relayer">cosmos-go-relayer</a>.</p>
<p><strong>Legend</strong>:</p>
<table><thead><tr><th>Term</th><th>Description</th></tr></thead><tbody>
<tr><td>❌</td><td>feature not supported</td></tr>
<tr><td>✅</td><td>feature is supported</td></tr>
<tr><td><code>Chain</code></td><td>chain related</td></tr>
<tr><td><code>Cl</code></td><td>client related</td></tr>
<tr><td><code>Conn</code></td><td>connection related</td></tr>
<tr><td><code>Chan</code></td><td>channel related</td></tr>
<tr><td><code>.._Handshake_..</code></td><td>can execute all transactions required to finish a handshake from a single command</td></tr>
<tr><td><code>.._&lt;msg&gt;_A</code></td><td>building and sending <code>msg</code> from a command that scans chain state</td></tr>
<tr><td><code>.._&lt;msg&gt;_P</code></td><td>building and sending <code>msg</code> from IBC event; doesn't apply to <code>.._Init</code> and <code>FT_Transfer</code> features</td></tr>
</tbody></table>
<p><strong>Feature comparison between Hermes and the Go relayer</strong> </p>
<table><thead><tr><th>Features \      Status</th><th style="text-align: center">Hermes</th><th style="text-align: center">Cosmos Go</th><th style="text-align: left">Feature Details</th></tr></thead><tbody>
<tr><td>Restart</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">replays any IBC events that happened before restart</td></tr>
<tr><td>Multiple_Paths</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">relays on multiple paths concurrently</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Connection Delay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td>Cl_Misbehavior</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">monitors and submits IBC client misbehavior</td></tr>
<tr><td>Cl_Refresh</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">periodically refresh an on-chain client to prevent expiration</td></tr>
<tr><td>Packet Delay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Unordered</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Ordered</td><td style="text-align: center">✅</td><td style="text-align: center">❓</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cl_Tendermint_Create</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client creation</td></tr>
<tr><td>Cl_Tendermint_Update</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client update</td></tr>
<tr><td>Cl_Tendermint_Upgrade</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">tendermint light client upgrade</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Conn_Open_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Conn_Open_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Open_Handshake_Optimistic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">open a channel on a non-Open connection</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Chan_Close_Handshake_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Chan_Close_Handshake_A</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left"></td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>FT_Transfer</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">can submit an ICS-20 fungible token transfer message</td></tr>
<tr><td>ICA_Relay</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td><td style="text-align: left">can relay ICS-27 Interchain account packets</td></tr>
<tr><td>Packet_Recv_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Recv_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Timeout_A</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Timeout_P</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left"></td></tr>
<tr><td>Packet_TimeoutClose_A</td><td style="text-align: center">✅</td><td style="text-align: center">❓</td><td style="text-align: left"></td></tr>
<tr><td>Packet_TimeoutClose_P</td><td style="text-align: center">✅</td><td style="text-align: center">❓</td><td style="text-align: left"></td></tr>
<tr><td>Packet_Optimistic</td><td style="text-align: center">❌</td><td style="text-align: center">❓</td><td style="text-align: left">relay packets over non-Open channels</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Cl_Non_Tendermint</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">supports non tendermint IBC light clients</td></tr>
<tr><td>Chain_Non_Cosmos</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">supports non cosmos-SDK chains</td></tr>
<tr><td></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
<tr><td>Mgmt_Static</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: left">provides means for configuration prior to being started</td></tr>
<tr><td>Mgmt_Dynamic</td><td style="text-align: center">❌</td><td style="text-align: center">❌</td><td style="text-align: left">provides means for configuration and monitoring during runtime</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In order to run Hermes, please make sure you have all the 
<a href="./pre_requisites.html">pre-requisites</a> installed on your machine.</p>
<p>Once you have these pre-requisites, you can
<a href="./installation.html">build and run Hermes</a>.</p>
<blockquote>
<p>The instructions in this guide have been tested on <code>Linux</code> and <code>MacOS</code> 
environments. Most of the commands should work on both environments. Even 
though you can build and run the relayer on <code>Windows</code> (since we develop it 
in Rust and it supports cross platform compilation) we have not tested the 
relayer on <code>Windows</code> and we do not support this operating system at this time.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h1>
<h2 id="1-rust"><a class="header" href="#1-rust">1. Rust</a></h2>
<p>The IBC Relayer is developed with the <a href="https://www.rust-lang.org">Rust</a> programming language. In order to build and run the relayer you need to install and configure <code>Rust</code> on your machine.</p>
<h3 id="fresh-rust-installation"><a class="header" href="#fresh-rust-installation">Fresh Rust installation</a></h3>
<p>For instructions on how to install <code>Rust</code> on your machine please follow the official <a href="https://www.rust-lang.org/tools/install"><code>Notes about Rust Installation</code></a>.</p>
<p>The provided instructions will install all the Rust toolchain including <code>rustc</code>, <code>cargo</code>, and <code>rustup</code> that are required to build the project.</p>
<h3 id="version-requirements"><a class="header" href="#version-requirements">Version requirements</a></h3>
<p>Hermes is developed and tested using the latest version of Rust, <code>1.58</code> at
the moment. To check that your toolchain is up-to-date run:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<p>In case you already had installed the Rust toolchain in the past, you can
update your installation by running <code>rustup update</code>.</p>
<h3 id="testing-the-installation"><a class="header" href="#testing-the-installation">Testing the installation</a></h3>
<p>After you install the <code>Rust</code> toolchain you can execute the following command:</p>
<pre><code class="language-shell">cargo version
</code></pre>
<p>This should display the <code>cargo</code> version and confirm the proper installation.</p>
<h2 id="2-golang"><a class="header" href="#2-golang">2. Golang</a></h2>
<p>You will also need the <strong>Go</strong> programming language installed and configured on your machine. This is a requirement for the the section <a href="./tutorials/local-chains/gaia.html">Installing Gaia</a> in the <a href="./tutorials/local-chains/index.html">Two Local Chains</a> tutorial.</p>
<p>To install and configure Golang on your machine please follow the <a href="https://golang.org/doc/install">Golang official documentation</a>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Next, go to the <a href="./installation.html">Installation</a> section to learn how to build Hermes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-the-relayer"><a class="header" href="#install-the-relayer">Install the relayer</a></h1>
<p>There are two main approaches for obtaining Hermes:</p>
<ol>
<li>
<p>Installation:</p>
<ol>
<li>If you are running on a Unix machine (Linux/MacOS), then the simplest
option is to <a href="installation.html#install-by-downloading">download the latest binary</a>.</li>
<li>You can also install via <a href="installation.html#install-via-cargo">Cargo</a>.</li>
</ol>
</li>
<li>
<p>Alternatively, <a href="installation.html#build-from-source">build Hermes directly from source</a>.</p>
</li>
</ol>
<h2 id="install-by-downloading"><a class="header" href="#install-by-downloading">Install by downloading</a></h2>
<p>Simply head to the GitHub <a href="https://github.com/informalsystems/ibc-rs/releases">Releases</a> page and download the latest
version of Hermes binary matching your platform:</p>
<ul>
<li>MacOS: <code>hermes-v0.11.1-x86_64-apple-darwin.tar.gz</code> (or .zip),</li>
<li>Linux: <code>hermes-v0.11.1-x86_64-unknown-linux-gnu.tar.gz</code> (or .zip).</li>
</ul>
<p>The step-by-step instruction below should carry you through the whole process:</p>
<ol>
<li>
<p>Make the directory where we'll place the binary:</p>
<pre><code class="language-shell">mkdir -p $HOME/.hermes/bin
</code></pre>
</li>
<li>
<p>Extract the binary archive:</p>
<pre><code class="language-shell">tar -C $HOME/.hermes/bin/ -vxzf $ARCHIVE_NAME
</code></pre>
</li>
<li>
<p>Update your path, by adding this line in your <code>.bashrc</code> or <code>.zshrc</code> shell
configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.hermes/bin:$PATH&quot;
</code></pre>
</li>
</ol>
<blockquote>
<p>NOTE: The binary may be initially prevented from running if you're
on MacOS.
See the <a href="https://support.apple.com/en-gb/HT202491">&quot;Open Anyway&quot; instructions from this support forum</a>
if that is the case.</p>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes 0.11.1
</code></pre>
<h2 id="install-via-cargo"><a class="header" href="#install-via-cargo">Install via Cargo</a></h2>
<blockquote>
<p>NOTE: This approach assumes you have installed all
the <a href="./pre_requisites.html">pre-requisites</a> on your machine.</p>
</blockquote>
<p>Hermes is packaged in the <code>ibc-relayer-cli</code> Rust crate.
To install the latest release of Hermes, run the following command in a terminal:</p>
<pre><code class="language-shell">cargo install ibc-relayer-cli --bin hermes --locked
</code></pre>
<p>This will download and build the crate <code>ibc-relayer-cli</code>, and install the
<code>hermes</code> binary in <code>$HOME/.cargo/bin</code>.</p>
<blockquote>
<p>If you have not installed Rust and Cargo via <a href="https://rustup.rs">rustup.rs</a>, you may need to
add the <code>$HOME/.cargo/bin</code> directory to your <code>PATH</code> environment variable.
For most shells, this can be done by adding the following line to your
<code>.bashrc</code> or <code>.zshrc</code> configuration file:</p>
<pre><code class="language-shell">export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
</blockquote>
<p>You should now be able to run Hermes by invoking the <code>hermes</code> executable.</p>
<pre><code class="language-shell">hermes version
</code></pre>
<pre><code>hermes 0.11.1
</code></pre>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build from source</a></h2>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the repository</a></h3>
<p>Open a terminal and clone the <code>ibc-rs</code> repository:</p>
<pre><code class="language-shell">git clone https://github.com/informalsystems/ibc-rs.git
</code></pre>
<p>Change to the repository directory</p>
<pre><code class="language-shell">cd ibc-rs
</code></pre>
<h3 id="checkout-the-latest-release"><a class="header" href="#checkout-the-latest-release">Checkout the latest release</a></h3>
<p>Go to the <a href="https://github.com/informalsystems/ibc-rs/releases">ibc-rs releases</a> page to see what is the most recent release.</p>
<p>Then checkout the release, for example if the most recent release is <code>v0.11.1</code> then execute the command:</p>
<pre><code class="language-shell">git checkout v0.11.1
</code></pre>
<h3 id="building-with-cargo-build"><a class="header" href="#building-with-cargo-build">Building with <code>cargo build</code></a></h3>
<p>This command builds all the crates from the <a href="https://github.com/informalsystems/ibc-rs"><strong><code>ibc-rs</code></strong></a> repository, namely: the <a href="https://github.com/informalsystems/ibc-rs/tree/master/modules"><strong><code>ibc</code></strong></a> modules crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer"><strong><code>ibc-relayer</code></strong></a> crate, <a href="https://github.com/informalsystems/ibc-rs/tree/master/proto"><strong><code>ibc-proto</code></strong></a> crate, and the <a href="https://github.com/informalsystems/ibc-rs/tree/master/relayer-cli"><strong><code>ibc-relayer-cli</code></strong></a> crate.
The last of these crates contains the <code>hermes</code> binary.</p>
<pre><code class="language-shell">cargo build --release --bin hermes
</code></pre>
<p><a name="telemetry-support"></a></p>
<blockquote>
<p>By default, Hermes bundles a <a href="./telemetry.html">telemetry service and server</a>.
To build Hermes without telemetry support, and get a smaller executable,
supply the <code>--no-default-features flag</code> to <code>cargo build</code>:</p>
<pre><code class="language-shell">cargo build --release --no-default-features --bin hermes
</code></pre>
</blockquote>
<p>If the build is successful, the <code>hermes</code> executable will be located in the following location:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<p><strong>Troubleshooting</strong>:
In case the <code>cargo build</code> command above fails, as a first course of action we
recommend trying to run the same command with the additional <code>locked</code> flag:</p>
<pre><code class="language-shell">cargo build --release --bin hermes --locked
</code></pre>
<h3 id="running-for-the-first-time"><a class="header" href="#running-for-the-first-time">Running for the first time</a></h3>
<p>If you run the <code>hermes</code> without any additional parameters you should see the usage and help information:</p>
<pre><code class="language-shell">./target/release/hermes
</code></pre>
<pre><code>hermes 0.11.1
Informal Systems &lt;hello@informal.systems&gt;

USAGE:
    hermes &lt;SUBCOMMAND&gt;

SUBCOMMANDS:
    help       Get usage information
    config     Validate Hermes configuration file
    keys       Manage keys in the relayer for each chain
    create     Create objects (client, connection, or channel) on chains
    update     Update objects (clients) on chains
    upgrade    Upgrade objects (clients) after chain upgrade
    start      Start the relayer
    query      Query objects from the chain
    tx         Create and send IBC transactions
    listen     Listen to and display IBC events emitted by a chain
    misbehaviour Listen to client update IBC events and handles misbehaviour
    version    Display version information
</code></pre>
<h3 id="creating-an-alias-for-the-executable"><a class="header" href="#creating-an-alias-for-the-executable">Creating an alias for the executable</a></h3>
<p>It might be easier to create an alias for <code>hermes</code> so you can just run it by specifying the executable name instead of the whole path. In order to create an alias execute the following command:</p>
<pre><code class="language-shell">alias hermes='cargo run --release --bin hermes --'
</code></pre>
<h2 id="shell-auto-completions"><a class="header" href="#shell-auto-completions">Shell auto-completions</a></h2>
<p>The <code>completions</code> subcommand of Hermes can be used to output a completion script
for a choice of widely used command-line shells.
Refer to <code>hermes completions --help</code> for the list. Some shell-specific examples
of setting up auto-completion with this command are provided below; check your
shell configuration to decide on the suitable directory in which to install the script
and any further necessary modifications to the shell's startup files.</p>
<h3 id="bash"><a class="header" href="#bash">Bash</a></h3>
<pre><code class="language-sh">hermes completions bash &gt; ~/.local/share/bash-completion/completions/hermes
</code></pre>
<p>On a MacOS installation with Homebrew <code>bash-completion</code> formula installed, use </p>
<pre><code class="language-sh">hermes completions bash &gt; $(brew --prefix)/etc/bash_completion.d/hermes.bash-completion
</code></pre>
<h3 id="zsh"><a class="header" href="#zsh">Zsh</a></h3>
<pre><code class="language-sh">hermes completions zsh &gt; ~/.zfunc/_hermes
</code></pre>
<p>To make the shell load the script on initialization, add the directory to <code>fpath</code>
in your <code>~/.zshrc</code> before <code>compinit</code>:</p>
<pre><code>fpath+=~/.zfunc
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Go to the <a href="./config.html"><code>Configuration</code></a> section to learn how to create a configuration file to be used by Hermes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>In order to run Hermes, you will need to have a configuration file.</p>
<p>The format supported for the configuration file is <a href="https://toml.io/en/">TOML</a>.</p>
<p>By default, Hermes expects the configuration file to be located at <code>$HOME/.hermes/config.toml</code>.</p>
<p>This can be overridden by supplying the <code>-c</code> flag when invoking <code>hermes</code>, before the
name of the command to run, eg. <code>hermes -c my_config.toml query connection channels ibc-1 connection-1</code>.</p>
<blockquote>
<p>The current version of Hermes does not support managing the configuration file programmatically.
You will need to use a text editor to create the file and add content to it.</p>
</blockquote>
<pre><code class="language-bash">hermes [-c CONFIG_FILE] COMMAND
</code></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="config.html#configuration">Configuration</a></li>
<li><a href="config.html#adding-private-keys">Adding private keys</a></li>
<li><a href="config.html#example-configuration-file">Example configuration file</a></li>
<li><a href="config.html#update-the-configuration-without-restarting-hermes">Update the configuration without restarting Hermes</a></li>
<li><a href="config.html#next-steps">Next steps</a></li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The configuration file must have one <code>global</code> section, and one <code>chains</code> section for each chain.</p>
<blockquote>
<p><strong>Note:</strong> As of 0.6.0, the Hermes configuration file is self-documented.
Please read the configuration file <a href="https://github.com/informalsystems/ibc-rs/blob/v0.11.1/config.toml"><code>config.toml</code></a>
itself for the most up-to-date documentation of parameters.</p>
</blockquote>
<p>By default, Hermes will relay on all channels available between all the configured chains.
In this way, every configured chain will act as a source (in the sense that Hermes listens for events)
and as a destination (to relay packets that others chains have sent).</p>
<p>For example, if there are only two chains configured, then Hermes will only relay packets between those two,
i.e. the two chains will serve as a source for each other, and likewise as a destination for each other's relevant events.
Hermes will ignore all events that pertain to chains which are unknown (ie. not present in config.toml).</p>
<p>To restrict relaying on specific channels, or uni-directionally, you can use <a href="https://github.com/informalsystems/ibc-rs/blob/v0.11.1/config.toml#L207-L224">packet filtering policies</a>.</p>
<h2 id="adding-private-keys"><a class="header" href="#adding-private-keys">Adding private keys</a></h2>
<p>For each chain configured you need to add a private key for that chain in order to submit <a href="./commands/raw/index.html">transactions</a>,
please refer to the <a href="./commands/keys/index.html">Keys</a> sections in order to learn how to add the private keys that are used by the relayer.</p>
<h2 id="example-configuration-file"><a class="header" href="#example-configuration-file">Example configuration file</a></h2>
<p>Here is a full example of a configuration file with two chains configured:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[rest]
enabled = true
host = '127.0.0.1'
port = 3000

[telemetry]
enabled = true
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'ibc-0'
rpc_addr = 'http://127.0.0.1:26657'
grpc_addr = 'http://127.0.0.1:9090'
websocket_addr = 'ws://localhost:26657/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
max_gas = 2000000
fee_granter = ''
gas_price = { price = 0.001, denom = 'stake' }
gas_adjustment = 0.1
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://localhost:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
max_gas = 2000000
gas_price = { price = 0.001, denom = 'stake' }
gas_adjustment = 0.1
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }
</code></pre>
<h2 id="update-the-configuration-without-restarting-hermes"><a class="header" href="#update-the-configuration-without-restarting-hermes">Update the configuration without restarting Hermes</a></h2>
<p>Before Hermes 0.6.1, the only way to get Hermes to pick up a change in the
configuration was to stop and restart Hermes.</p>
<p>As of version 0.6.1, Hermes will react to receiving a <code>SIGHUP</code> signal
by reloading the <code>[chains]</code> section of the configuration, and
stopping, starting or restarting the affected workers.</p>
<blockquote>
<p>⚠️  <strong>Warning:</strong> the configuration reload feature only supports
adding, removing, or updating configuration of chains. It does
not support dynamically changing global features, such as the
filtering mechanism or logging level.</p>
</blockquote>
<p>For example, say you start with the configuration given in the previous section
in <code>~/.hermes/config.toml</code>, ie. with two chains <code>ibc-0</code> and <code>ibc-1</code>.</p>
<ol>
<li>
<p>Start three chains <code>ibc-0</code>, <code>ibc-1</code> and <code>ibc-2</code>:</p>
<pre><code class="language-shell">./scripts/dev-env ibc-0 ibc-1 ibc-2
</code></pre>
</li>
<li>
<p>Start Hermes</p>
<pre><code class="language-shell">hermes start
</code></pre>
</li>
<li>
<p>Add the configuration for the chain <code>ibc-2</code> to the configuration file:</p>
<pre><code class="language-toml">[[chains]]
id = 'ibc-2'
rpc_addr = 'http://127.0.0.1:26457'
grpc_addr = 'http://127.0.0.1:9092'
websocket_addr = 'ws://127.0.0.1:26457/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
max_gas = 20000000
gas_price = { price = 0.001, denom = 'stake' }
clock_drift = '5s'
trusting_period = '14days'
</code></pre>
</li>
<li>
<p>Change the configuration of the chain <code>ibc-0</code>, eg. the <code>max_gas</code> property.</p>
</li>
<li>
<p>Send a <code>SIGHUP</code> signal to the <code>hermes</code> process:</p>
<blockquote>
<p>⚠️  <strong>Warning:</strong> the command below will send a <code>SIGHUP</code> signal to the first
process in the list emitted by <code>ps aux</code> which contains the string <code>hermes</code>.
Alternatively, you can look up the process ID (PID) of the <code>hermes</code> process
you want to target and use <code>kill -SIGHUP PID</code>.</p>
</blockquote>
<pre><code class="language-shell">ps aux | rg hermes | awk '{ print $2 }' | head -n1 | xargs -I{} kill -SIGHUP {}
</code></pre>
</li>
<li>
<p>Watch the output of Hermes, it will show that Hermes has picked up the changes in
the config. Hermes is now relaying between the three chains and using the new
maximum amount of gas specified for <code>ibc-0</code>.</p>
<pre><code>...

INFO reloading configuration (triggered by SIGHUP)
INFO configuration successfully reloaded
INFO updating existing chain chain.id=ibc-1
INFO adding new chain chain.id=ibc-2
</code></pre>
</li>
</ol>
<p>To make sure Hermes ends up in the expected state, check out the documentation
on <a href="help.html#inspecting-the-relayer-state">inspecting the relayer state</a>.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next steps</a></h2>
<p>Now that you learned how to build the relayer and how to create a configuration file, you can go to the <a href="./tutorials/local-chains/index.html"><code>Two Chains</code></a> tutorial to learn how to perform some local testing connecting the relayer to two local chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h1>
<p><em>Since version 0.4.0.</em></p>
<p>To gain a better understanding of the status and activity of the relayer,
Hermes features a built-in telemetry service based on the <a href="https://opentelemetry.io">OpenTelemetry</a> observability framework,
whose metrics can be exposed over HTTP for integration with the <a href="https://prometheus.io">Prometheus</a> monitoring system.</p>
<p>The official Hermes builds for Linux and macOS come with telemetry support since version 0.4.0,
and can be <a href="https://github.com/informalsystems/ibc-rs/releases">downloaded directly from the GitHub Releases</a> page.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>The telemetry service is not active by default, and must be enabled in the relayer configuration:</p>
<pre><code class="language-toml">[telemetry]
enabled = true
host    = '127.0.0.1'
port    = 3001
</code></pre>
<p>Please see the <a href="./config.html#telemetry">relevant section in the <em>Configuration</em> page</a> for details about the configuration options.</p>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>The following table describes the metrics currently tracked by the telemetry service:</p>
<table><thead><tr><th>Name</th><th>Description</th><th>OpenTelemetry type</th></tr></thead><tbody>
<tr><td><code>workers</code></td><td>Number of workers per object</td><td><code>i64</code> UpDownCounter</td></tr>
<tr><td><code>ibc_client_updates</code></td><td>Number of client updates performed per client</td><td><code>u64</code> Counter</td></tr>
<tr><td><code>ibc_client_misbehaviours</code></td><td>Number of misbehaviours detected per client</td><td><code>u64</code> Counter</td></tr>
<tr><td><code>ibc_receive_packets</code></td><td>Number of receive packets relayed per channel</td><td><code>u64</code> Counter</td></tr>
<tr><td><code>ibc_acknowledgment_packets</code></td><td>Number of acknowledgment packets relayed per channel</td><td><code>u64</code> Counter</td></tr>
<tr><td><code>ibc_timeout_packets</code></td><td>Number of timeout packets relayed per channel</td><td><code>u64</code> Counter</td></tr>
</tbody></table>
<h2 id="integration-with-prometheus"><a class="header" href="#integration-with-prometheus">Integration with Prometheus</a></h2>
<p>With the settings , the telemetry service will be enabled and will serve the metrics using
the Prometheus encoder over HTTP at <a href="http://localhost:3001/metrics"><code>http://localhost:3001/metrics</code></a>.</p>
<p>After starting Hermes with <code>hermes start</code>, and letting it run for a while to relay packets,
open <a href="http://localhost:3001/metrics"><code>http://localhost:3001/metrics</code></a> in a browser, you should
see Prometheus-encoded metrics.</p>
<p>For example, with 3 channels and after transferring some tokens between the chains:</p>
<pre><code class="language-text"># HELP ibc_acknowledgment_packets Number of acknowledgment packets relayed per channel
# TYPE ibc_acknowledgment_packets counter
ibc_acknowledgment_packets{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 300
ibc_acknowledgment_packets{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-1&quot;,src_port=&quot;transfer&quot;} 100
ibc_acknowledgment_packets{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 48
ibc_acknowledgment_packets{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-1&quot;,src_port=&quot;transfer&quot;} 0
# HELP ibc_receive_packets Number of receive packets relayed per channel
# TYPE ibc_receive_packets counter
ibc_receive_packets{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 48
ibc_receive_packets{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-1&quot;,src_port=&quot;transfer&quot;} 0
ibc_receive_packets{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 300
ibc_receive_packets{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-1&quot;,src_port=&quot;transfer&quot;} 100
# HELP ibc_timeout_packets Number of timeout packets relayed per channel
# TYPE ibc_timeout_packets counter
ibc_timeout_packets{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 1
ibc_timeout_packets{src_chain=&quot;ibc-0&quot;,src_channel=&quot;channel-1&quot;,src_port=&quot;transfer&quot;} 0
ibc_timeout_packets{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-0&quot;,src_port=&quot;transfer&quot;} 0
ibc_timeout_packets{src_chain=&quot;ibc-1&quot;,src_channel=&quot;channel-1&quot;,src_port=&quot;transfer&quot;} 0
# HELP workers Number of workers per object
# TYPE workers gauge
workers{type=&quot;client&quot;} 6
workers{type=&quot;packet&quot;} 4
</code></pre>
<h3 id="visualization-with-grafana"><a class="header" href="#visualization-with-grafana">Visualization with Grafana</a></h3>
<p>Here's how these metrics look like in <a href="https://prometheus.io/docs/visualization/grafana/">Grafana</a> with a Prometheus data source:</p>
<p><img src="./images/grafana.png" alt="Hermes metrics in Grafana" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api"><a class="header" href="#rest-api">REST API</a></h1>
<p><em>Since version 0.7.0.</em></p>
<p>Hermes features a built-in HTTP server which exposes information
about the relayer configuration and state via a REST API.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="rest-api.html#configuration">Configuration</a></li>
<li><a href="rest-api.html#endpoints">Endpoints</a>
<ul>
<li><a href="rest-api.html#get-version">GET <code>/version</code></a></li>
<li><a href="rest-api.html#get-chains">GET <code>/chains</code></a></li>
<li><a href="rest-api.html#get-chainid">GET <code>/chain/:id</code></a></li>
<li><a href="rest-api.html#get-state">GET <code>/state</code></a></li>
</ul>
</li>
</ul>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The REST API is not active by default, and must be enabled in the relayer configuration:</p>
<pre><code class="language-toml">[rest]
enabled = true
host    = '127.0.0.1'
port    = 3000
</code></pre>
<p>Please see the <a href="./config.html#rest">relevant section in the <em>Configuration</em> page</a> for details about the configuration options.</p>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<h3 id="get-version"><a class="header" href="#get-version">GET <code>/version</code></a></h3>
<p>This endpoint returns the version of the Hermes (under the <code>ibc-relayer</code> key) as well
as the version of the REST server itself (under the <code>ibc-relayer-rest</code> key).</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/version' | jq
</code></pre>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;ibc-relayer&quot;,
    &quot;version&quot;: &quot;0.11.1&quot;
  },
  {
    &quot;name&quot;: &quot;ibc-relayer-rest&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;
  }
]
</code></pre>
<h3 id="get-chains"><a class="header" href="#get-chains">GET <code>/chains</code></a></h3>
<p>This endpoint return the identifiers of the chains that Hermes is connected to.
Those identifiers can be used with the <code>/chain/:id</code> endpoint to gather more
information about each chain's configuration. See the next section for more details.</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/chains' | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: [
    &quot;ibc-0&quot;,
    &quot;ibc-1&quot;
  ]
}
</code></pre>
<h3 id="get-chainid"><a class="header" href="#get-chainid">GET <code>/chain/:id</code></a></h3>
<p>This endpoint returns the configuration of the chain with the given identifier,
where <code>:id</code> stands for the identififer.</p>
<p><strong>Example</strong></p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/chain/ibc-0' | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;id&quot;: &quot;ibc-0&quot;,
    &quot;rpc_addr&quot;: &quot;http://127.0.0.1:26657/&quot;,
    &quot;websocket_addr&quot;: &quot;ws://127.0.0.1:26657/websocket&quot;,
    &quot;grpc_addr&quot;: &quot;http://127.0.0.1:9090/&quot;,
    &quot;rpc_timeout&quot;: &quot;10s&quot;,
    &quot;account_prefix&quot;: &quot;cosmos&quot;,
    &quot;key_name&quot;: &quot;testkey&quot;,
    &quot;store_prefix&quot;: &quot;ibc&quot;,
    &quot;max_gas&quot;: 900000000,
    &quot;gas_adjustment&quot;: null,
    &quot;max_msg_num&quot;: 60,
    &quot;max_tx_size&quot;: 2097152,
    &quot;clock_drift&quot;: &quot;5s&quot;,
    &quot;trusting_period&quot;: &quot;14days&quot;,
    &quot;trust_threshold&quot;: {
      &quot;numerator&quot;: &quot;1&quot;,
      &quot;denominator&quot;: &quot;3&quot;
    },
    &quot;gas_price&quot;: {
      &quot;price&quot;: 0.001,
      &quot;denom&quot;: &quot;stake&quot;
    },
    &quot;packet_filter&quot;: {
      &quot;policy&quot;: &quot;allowall&quot;
    }
  }
}
</code></pre>
<h3 id="get-state"><a class="header" href="#get-state">GET <code>/state</code></a></h3>
<p>This endpoint returns the current state of the relayer,
namely which chains it is connected to, as well as a description
of all the workers which are currently active.</p>
<pre><code>❯ curl -s -X GET 'http://127.0.0.1:3000/state' | jq
</code></pre>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;success&quot;,
  &quot;result&quot;: {
    &quot;chains&quot;: [
      &quot;ibc-0&quot;,
      &quot;ibc-1&quot;
    ],
    &quot;workers&quot;: {
      &quot;Client&quot;: [
        {
          &quot;id&quot;: 3,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-0&quot;
          }
        },
        {
          &quot;id&quot;: 4,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-0&quot;
          }
        },
        {
          &quot;id&quot;: 1,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-1&quot;
          }
        },
        {
          &quot;id&quot;: 2,
          &quot;object&quot;: {
            &quot;type&quot;: &quot;Client&quot;,
            &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
            &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
            &quot;src_chain_id&quot;: &quot;ibc-1&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>This section includes tutorials for some common relayer uses cases and commands. You can also refer to the <a href="tutorials/../commands/index.html">Commands Reference</a> section to learn more about individual commands.</p>
<h2 id="basic-tutorials"><a class="header" href="#basic-tutorials">Basic tutorials</a></h2>
<p><strong><a href="tutorials/./local-chains/index.html">Two Local Chains</a></strong></p>
<p>In this tutorial you will learn how to start two local <a href="https://github.com/cosmos/gaia"><code>Cosmos Gaia</code></a> chains that support the <code>IBC</code> protocol and start relaying packets between them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-relayer-with-two-local-chains"><a class="header" href="#tutorial-relayer-with-two-local-chains">Tutorial: Relayer with two local chains</a></h1>
<p>In this tutorial we will show how you can test the relayer against two chains, we provide a script that can start two separate chains and configure them automatically. This is the easiest way to get started.</p>
<p>The script starts two <a href="https://github.com/cosmos/gaia"><code>gaia</code></a> chains that support the <code>IBC</code> protocol.</p>
<p>Follow the steps in this tutorial section starting with the <a href="tutorials/local-chains/./gaia.html">Install Gaia</a> section.# Local chains</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-gaia"><a class="header" href="#install-gaia">Install Gaia</a></h1>
<p>The script to start the chains requires gaia to be installed.</p>
<blockquote>
<p><strong>NOTE</strong>: This assumes you have <code>Golang</code> programming language installed on 
your machine. If not, please ensure you install before proceeding. See 
more details in the <a href="tutorials/local-chains/../../pre_requisites.html#2-golang">Pre-requisites</a> section.</p>
</blockquote>
<h4 id="clone-gaia"><a class="header" href="#clone-gaia">Clone gaia</a></h4>
<p>Clone the repository from Github:</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/gaia.git ~/go/src/github.com/cosmos/gaia
</code></pre>
<h4 id="build-and-install"><a class="header" href="#build-and-install">Build and Install</a></h4>
<p>Run the <code>make</code> command to build and install <code>gaiad</code></p>
<pre><code class="language-shell">cd ~/go/src/github.com/cosmos/gaia
git checkout v4.2.1
make install
</code></pre>
<p>If the command above is successful you can run the following command to ensure it was properly installed:</p>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<p>Output:</p>
<pre><code class="language-shell">name: gaia
server_name: gaiad
version: v4.2.1
commit: dbd8a6fb522c571debf958837f9113c56d418f6b
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>In the next section you will learn how to <a href="tutorials/local-chains/./start.html">start two local chains</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="start-the-local-chains"><a class="header" href="#start-the-local-chains">Start the local chains</a></h1>
<p>In this chapter, you will learn how to spawn two Gaia chains, and use Hermes to relay packets between them.
To spawn the chains and configure Hermes accordingly, we will make use of script bundled in the <code>ibc-rs</code> repository.</p>
<p>To this end, clone the <code>ibc-rs</code> repository and check out the current version:</p>
<pre><code class="language-bash">git clone git@github.com:informalsystems/ibc-rs.git
cd ibc-rs
git checkout v0.11.1
</code></pre>
<h3 id="stop-existing-gaiad-processes"><a class="header" href="#stop-existing-gaiad-processes">Stop existing <code>gaiad</code> processes</a></h3>
<p>If this is not the first time you are running the script, you can manually stop the two gaia instances executing the following command to kill all <code>gaiad</code> processes:</p>
<pre><code class="language-shell">killall gaiad
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you have any <code>Docker</code> containers running that might be using the same ports as <code>gaiad</code> (e.g. port 26657 or port 9090), please ensure you stop them first before proceeding to the next step.</p>
</blockquote>
<h3 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h3>
<p>In order to run the script, you will need a <code>TOML</code> configuration file to be passed as a parameter. Please check the <a href="tutorials/local-chains/../../config.html"><code>Configuration</code></a> section for more information about the relayer configuration file.</p>
<p>The following configuration file in the <code>ibc-rs</code> repository folder can be used for running the local chains:</p>
<p><strong>config.toml</strong></p>
<pre><code class="language-toml"># The global section has parameters that apply globally to the relayer operation.
[global]

# Specify the verbosity for the relayer logging output. Default: 'info'
# Valid options are 'error', 'warn', 'info', 'debug', 'trace'.
log_level = 'info'


# Specify the mode to be used by the relayer. [Required]
[mode]

# Specify the client mode.
[mode.clients]

# Whether or not to enable the client workers. [Required]
enabled = true

# Whether or not to enable periodic refresh of clients. [Default: true]
# Note: Even if this is disabled, clients will be refreshed automatically if
#      there is activity on a connection or channel they are involved with.
refresh = true

# Whether or not to enable misbehaviour detection for clients. [Default: false]
misbehaviour = true

# Specify the connections mode.
[mode.connections]

# Whether or not to enable the connection workers for handshake completion. [Required]
enabled = false

# Specify the channels mode.
[mode.channels]

# Whether or not to enable the channel workers for handshake completion. [Required]
enabled = false

# Specify the packets mode.
[mode.packets]

# Whether or not to enable the packet workers. [Required]
enabled = true

# Parametrize the periodic packet clearing feature.
# Interval (in number of blocks) at which pending packets
# should be eagerly cleared. A value of '0' will disable
# periodic packet clearing. [Default: 100]
clear_interval = 100

# Whether or not to clear packets on start. [Default: false]
clear_on_start = true

# Toggle the transaction confirmation mechanism.
# The tx confirmation mechanism periodically queries the `/tx_search` RPC
# endpoint to check that previously-submitted transactions
# (to any chain in this config file) have delivered successfully.
# Experimental feature. Affects telemetry if set to false.
# [Default: true]
tx_confirmation = true

# The REST section defines parameters for Hermes' built-in RESTful API.
# https://hermes.informal.systems/rest.html
[rest]

# Whether or not to enable the REST service. Default: false
enabled = true

# Specify the IPv4/6 host over which the built-in HTTP server will serve the RESTful
# API requests. Default: 127.0.0.1
host = '127.0.0.1'

# Specify the port over which the built-in HTTP server will serve the restful API
# requests. Default: 3000
port = 3000


# The telemetry section defines parameters for Hermes' built-in telemetry capabilities.
# https://hermes.informal.systems/telemetry.html
[telemetry]

# Whether or not to enable the telemetry service. Default: false
enabled = true

# Specify the IPv4/6 host over which the built-in HTTP server will serve the metrics
# gathered by the telemetry service. Default: 127.0.0.1
host = '127.0.0.1'

# Specify the port over which the built-in HTTP server will serve the metrics gathered
# by the telemetry service. Default: 3001
port = 3001


# A chains section includes parameters related to a chain and the full node to which
# the relayer can send transactions and queries.
[[chains]]

# Specify the chain ID. Required
id = 'ibc-0'

# Specify the RPC address and port where the chain RPC server listens on. Required
rpc_addr = 'http://127.0.0.1:26657'

# Specify the GRPC address and port where the chain GRPC server listens on. Required
grpc_addr = 'http://127.0.0.1:9090'

# Specify the WebSocket address and port where the chain WebSocket server
# listens on. Required
websocket_addr = 'ws://127.0.0.1:26657/websocket'

# Specify the maximum amount of time (duration) that the RPC requests should
# take before timing out. Default: 10s (10 seconds)
# Note: Hermes uses this parameter _only_ in `start` mode; for all other CLIs,
# Hermes uses a large preconfigured timeout (on the order of minutes).
rpc_timeout = '10s'

# Specify the prefix used by the chain. Required
account_prefix = 'cosmos'

# Specify the name of the private key to use for signing transactions. Required
# See the Adding Keys chapter for more information about managing signing keys:
#   https://hermes.informal.systems/commands/keys/index.html#adding-keys
key_name = 'testkey'

# Specify the address type which determines:
# 1) address derivation;
# 2) how to retrieve and decode accounts and pubkeys;
# 3) the message signing method.
# The current configuration options are for Cosmos SDK and Ethermint.
#
# Example configuration for chains based on Ethermint library:
#
# address_type = { derivation = 'ethermint', proto_type = { pk_type = '/injective.crypto.v1beta1.ethsecp256k1.PubKey' } }
#
# Default: { derivation = 'cosmos' }, i.e. address derivation as in Cosmos SDK.
# Warning: This is an advanced feature! Modify with caution.
address_type = { derivation = 'cosmos' }

# Specify the store prefix used by the on-chain IBC modules. Required
# Recommended value for Cosmos SDK: 'ibc'
store_prefix = 'ibc'

# Specify the default amount of gas to be used in case the tx simulation fails,
# and Hermes cannot estimate the amount of gas needed.
# Default: 100 000
default_gas = 100000

# Specify the maximum amount of gas to be used as the gas limit for a transaction.
# Default: 400 000
max_gas = 400000

# Specify the price per gas used of the fee to submit a transaction and
# the denomination of the fee. Required
gas_price = { price = 0.001, denom = 'stake' }

# Specify the ratio by which to increase the gas estimate used to compute the fee,
# to account for potential estimation error. Default: 0.1, ie. 10%.
# Valid range: 0.0 to 1.0 (inclusive)
gas_adjustment = 1.0

# Specify how many IBC messages at most to include in a single transaction.
# Default: 30
max_msg_num = 30

# Specify the maximum size, in bytes, of each transaction that Hermes will submit.
# Default: 2097152 (2 MiB)
max_tx_size = 2097152

# Specify the maximum amount of time to tolerate a clock drift.
# The clock drift parameter defines how much new (untrusted) header's time
# can drift into the future. Default: 5s
clock_drift = '5s'

# Specify the maximum time per block for this chain.
# The block time together with the clock drift are added to the source drift to estimate
# the maximum clock drift when creating a client on this chain. Default: 10s
# For cosmos-SDK chains a good approximation is `timeout_propose` + `timeout_commit`
max_block_time = '10s'

# Specify the amount of time to be used as the light client trusting period.
# It should be significantly less than the unbonding period
# (e.g. unbonding period = 3 weeks, trusting period = 2 weeks).
# Default: 2/3 of the `unbonding period` for Cosmos SDK chains
trusting_period = '14days'

# Specify the trust threshold for the light client, ie. the maximum fraction of validators
# which have changed between two blocks.
# Default: { numerator = '1', denominator = '3' }, ie. 1/3.
# Warning: This is an advanced feature! Modify with caution.
trust_threshold = { numerator = '1', denominator = '3' }

# Specify a string that Hermes will use as a memo for each transaction it submits
# to this chain. The string is limited to 50 characters. Default: '' (empty).
# Note: Hermes will append to the string defined here additional
# operational debugging information, e.g., relayer build version.
memo_prefix = ''

# This section specifies the filters for policy based relaying.
#
# Default: no policy / filters, allow all packets on all channels.
#
# Only packet filtering based on channel identifier can be specified.
# A channel filter has two fields:
# 1. `policy` - one of two types are supported:
#       - 'allow': permit relaying _only on_ the port/channel id in the list below,
#       - 'deny': permit relaying on any channel _except for_ the list below.
# 2. `list` - the list of channels specified by the port and channel identifiers.
#
# Example configuration of a channel filter, denying packet relaying on channel with port ID 'transfer' and channel ID 'channel-0':
#
# [chains.packet_filter]
# policy = 'deny'
# list = [
#   ['transfer', 'channel-0'],
# ]

# Specify that the transaction fees should be payed from this fee granter's account.
# Optional. If unspecified (the default behavior), then no fee granter is used, and
# the account specified in `key_name` will pay the tx fees for all transactions
# submitted to this chain.
# fee_granter = ''

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://127.0.0.1:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
default_gas = 100000
max_gas = 400000
gas_price = { price = 0.001, denom = 'stake' }
gas_adjustment = 0.1
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '10s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }
address_type = { derivation = 'cosmos' }
</code></pre>
<h4 id="saving-the-configuration-file"><a class="header" href="#saving-the-configuration-file">Saving the configuration file</a></h4>
<h5 id="create-the-configtoml-file"><a class="header" href="#create-the-configtoml-file">Create the config.toml file</a></h5>
<pre><code class="language-shell">mkdir -p $HOME/.hermes &amp;&amp; touch $HOME/.hermes/config.toml
</code></pre>
<h5 id="add-content-to-the-configuration-file"><a class="header" href="#add-content-to-the-configuration-file">Add content to the configuration file:</a></h5>
<p>You can use your preferred text editor. If using <code>vi</code> you can run:</p>
<pre><code class="language-shell">vi ~/.hermes/config.toml
</code></pre>
<p>Then just <strong><code>copy</code></strong> the content for <code>config.toml</code> above and <strong><code>paste</code></strong> into this file.</p>
<h3 id="running-the-script-to-start-the-chains"><a class="header" href="#running-the-script-to-start-the-chains">Running the script to start the chains</a></h3>
<p>From the <code>ibc-rs</code> repository folder run the following script with the parameters below to start the chains (<code>ibc-0</code> and <code>ibc-1</code>)
and import the signing keys into the keyring:</p>
<pre><code class="language-bash">./scripts/dev-env ~/.hermes/config.toml ibc-0 ibc-1
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If the script above prompts you to delete the data folder just answer <strong>'yes'</strong></p>
</blockquote>
<p>The script configures and starts two <strong><code>gaiad</code></strong> instances, one named <strong><code>ibc-0</code></strong> and the other <strong><code>ibc-1</code></strong></p>
<pre class="mermaid">graph TD
    A[dev-env] --&gt;|run| C(start chains)
    C --&gt;|gaiad| D[ibc-0]
    C --&gt;|gaiad| F[ibc-1]
</pre>
<p>If the script runs successfully you should see a message similar to the one below in the terminal:</p>
<pre><code class="language-shell">GAIA VERSION INFO: v4.2.1
Generating gaia configurations...
Creating gaiad instance: home=./data | chain-id=ibc-0 | p2p=:26656 | rpc=:26657 | profiling=:6060 | grpc=:9090 | samoleans=:100000000000
Change settings in config.toml file...
Start gaia on grpc port: 9090...
Balances for validator 'cosmos15cugtww7rwmayvshfznuxam55jsv23xh3jdeqv' @ 'tcp://localhost:26657'
balances:
- amount: &quot;0&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Balances for user 'cosmos1usn8g2rj9q48y245pql9589zf9m8srcpxtzklg' @ 'tcp://localhost:26657'
balances:
- amount: &quot;100000000000&quot;
  denom: samoleans
- amount: &quot;100000000000&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Creating gaiad instance: home=./data | chain-id=ibc-1 | p2p=:26556 | rpc=:26557 | profiling=:6061 | grpc=:9091 | samoleans=:100000000000
Change settings in config.toml file...
Start gaia on grpc port: 9091...
Balances for validator 'cosmos1zdmr04w7c04ef4vkuur9c0vyvl78q45qjncmja' @ 'tcp://localhost:26557'
balances:
- amount: &quot;0&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
Balances for user 'cosmos12p6k2dta0lsd6n80tpz34yepfpv7u7fvedm5mp' @ 'tcp://localhost:26557'
balances:
- amount: &quot;100000000000&quot;
  denom: samoleans
- amount: &quot;100000000000&quot;
  denom: stake
pagination:
  next_key: null
  total: &quot;0&quot;
ibc-0 initialized. Watch file /Users/ancaz/rust/ibc-rs/data/ibc-0.log to see its execution.
ibc-1 initialized. Watch file /Users/ancaz/rust/ibc-rs/data/ibc-1.log to see its execution.
Building the Rust relayer...
Importing keys...
Success: Added key 'testkey' (cosmos1usn8g2rj9q48y245pql9589zf9m8srcpxtzklg) on chain ibc-0
Success: Added key 'testkey' (cosmos12p6k2dta0lsd6n80tpz34yepfpv7u7fvedm5mp) on chain ibc-1
Done!
</code></pre>
<h3 id="data-directory"><a class="header" href="#data-directory">Data directory</a></h3>
<p>The script creates a <strong><code>data</code></strong> directory in the current directory in order. The <strong><code>data</code></strong> directory contains the chain stores and configuration files.</p>
<p>The <strong><code>data</code></strong> directory has a tree structure similar to the one below:</p>
<pre><code class="language-shell">data
├── ibc-0
│   ├── config
│   ├── data
│   ├── keyring-test
│   ├── user_seed.json
│   ├── user2_seed.json
│   └── validator_seed.json
├── ibc-0.log
├── ibc-1
│   ├── config
│   ├── data
│   ├── keyring-test
│   ├── user_seed.json
│   ├── user2_seed.json
│   └── validator_seed.json
└── ibc-1.log

</code></pre>
<blockquote>
<p><strong>Tip</strong>: You can use the command <code>tree ./data/ -L 2</code> to view the folder structure above:</p>
</blockquote>
<h3 id="homehermes-directory"><a class="header" href="#homehermes-directory">$HOME/.hermes directory</a></h3>
<p>By the default <code>hermes</code> expects the configuration file to be in the <strong><code>$HOME/.hermes</code></strong> folder.</p>
<p>It also stores the private keys for each chain in this folder as outlined in the <a href="tutorials/local-chains/../../commands/keys/index.html">Keys</a> section.</p>
<p>After executing the <strong><code>dev-env</code></strong> script, this is how the folder should look like:</p>
<pre><code class="language-shell">$HOME/.hermes/
├── config.toml
└── keys
    ├── ibc-0
    │   └── keyring-test
    │       └── testkey.json
    └── ibc-1
        └── keyring-test
            └── testkey.json
</code></pre>
<h4 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h4>
<p><a href="tutorials/local-chains/./identifiers.html">The next section</a> describes how identifers for clients, connections and channels
are allocated, and will walk you through how to pre-allocate some identifers
to help matching them with their corresponding chains for the purpose of this tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>A chain allocates identifiers when it creates clients, connections and channels. These identifiers can subsequently be used to refer to existing clients, connections and channels.</p>
<blockquote>
<p>NOTE: If you want to ensure you get the same identifiers while following the tutorials, run the each of the three commands below <strong>once</strong> on <code>ibc-1</code>. This will ensure that when going through the tutorial, a second channel on <code>ibc-1</code> with identifier <code>channel-1</code> will created.</p>
</blockquote>
<p>Chains allocate identifiers using a chain specific allocation scheme. Currently, <em>cosmos-sdk</em> implementation uses the follow identifiers:</p>
<h3 id="1-client-identifiers"><a class="header" href="#1-client-identifiers">1. Client Identifiers</a></h3>
<p><strong><code>07-tendermint-&lt;n&gt;</code></strong> for tendermint clients</p>
<p>For example <code>07-tendermint-0</code> is assigned to the first client created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-1 ibc-0
</code></pre>
<pre><code class="language-json">Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height {
               revision: 1,
               height: 103,
           },
           client_id: ClientId(
               &quot;07-tendermint-0&quot;,
           ),
           client_type: Tendermint,
           consensus_height: Height {
               revision: 0,
               height: 112,
           },
       },
   ),
)
</code></pre>
<p>We will create a second client on <code>ibc-1</code> with identifier <code>07-tendermint-1</code> in the client tutorial.</p>
<h3 id="2-connection-identifiers"><a class="header" href="#2-connection-identifiers">2. Connection Identifiers</a></h3>
<p><strong><code>connection-&lt;n&gt;</code></strong> for connections</p>
<p>For example <code>connection-0</code> is assigned to the first connection created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-1 ibc-0 07-tendermint-0 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 1,
                height: 119,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
</code></pre>
<p>We will create a second connection on <code>ibc-1</code> with identifier <code>connection-1</code> in the connection tutorial.</p>
<h3 id="3-channel-identifiers"><a class="header" href="#3-channel-identifiers">3. Channel Identifiers</a></h3>
<p><code>channel-&lt;n&gt;</code> for channels</p>
<p>For example <code>channel-0</code> is assigned to the first channel created on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-1 ibc-0 connection-0 transfer transfer
</code></pre>
<pre><code class="language-json">Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 1,
                height: 225,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: None,
        },
    ),
)
</code></pre>
<p>In the following tutorials the <strong><code>ibc-0</code></strong> and <strong><code>ibc-1</code></strong> chains are setup and configured. </p>
<p>For clarity, the tutorials run on a setup where the identifiers allocated to the client, connection and channel on <strong><code>ibc-0</code></strong> are <strong><code>07-tendermint-0</code></strong>, <strong><code>connection-0</code></strong> and <strong><code>channel-0</code></strong> respectively. Identifiers allocated to the client, connection and channel on <strong><code>ibc-1</code></strong> are <strong><code>07-tendermint-1</code></strong>, <strong><code>connection-1</code></strong> and <strong><code>channel-1</code></strong> respectively.</p>
<p>Before going over the next sections, please ensure the commands above are executed.</p>
<h3 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h3>
<p>The following sections describe the commands to connect and relay packets between two chains. You can:</p>
<ol>
<li>use a <a href="tutorials/local-chains/./relay-paths/index.html">simplified approach</a> for managing relaying paths, or</li>
<li>use <a href="tutorials/local-chains/./raw/index.html">individual (raw) transactions</a> to create
all the necessary chain objects (clients, connections, channels) and relay packets.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect-the-chains-using-relay-paths"><a class="header" href="#connect-the-chains-using-relay-paths">Connect the chains using relay paths</a></h1>
<p>A relay path refers to a specific channel used to interconnect two chains and over which packets are being sent.</p>
<p>Hermes can be started to listen for packet events on the two ends of multiple paths and relay packets over these paths.
This can be done over a new path or over existing paths.</p>
<ul>
<li><a href="tutorials/local-chains/relay-paths/./create-new-path.html">Create a new path</a></li>
<li><a href="tutorials/local-chains/relay-paths/./multiple-paths.html">Packet relaying on multiple paths</a></li>
</ul>
<p>Before proceeding to the sections above, please first, make sure you followed the steps in the <a href="tutorials/local-chains/relay-paths/../identifiers.html">Identifiers section</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-new-path"><a class="header" href="#create-a-new-path">Create a new path</a></h1>
<p>Perform client creation, connection and channel handshake to establish a new path between the <code>transfer</code> ports on <code>ibc-0</code> and <code>ibc-1</code> chains.</p>
<pre><code class="language-shell">hermes create channel ibc-0 ibc-1 --port-a transfer --port-b transfer
</code></pre>
<p>If all the handshakes are performed successfully you should see a message similar to the one below:</p>
<pre><code class="language-json">Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0s,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}

</code></pre>
<p>Note that for each side, <em>a_side</em> (<strong>ibc-0</strong>) and <em>b_side</em> (<strong>ibc-1</strong>) there are a <strong>client_id</strong>, <strong>connection_id</strong>, <strong>channel_id</strong> and <strong>port_id</strong>.
With all these established, you have <a href="tutorials/local-chains/relay-paths/./multiple-paths.html">a path that you can relay packets over</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relay-packets-on-multiple-paths"><a class="header" href="#relay-packets-on-multiple-paths">Relay packets on multiple paths</a></h1>
<p>Hermes can relay packets over all current or future paths between the configured set of chains.</p>
<p>Follow the steps below to connect three chains together and relay packets between them:</p>
<ol>
<li>
<p>Paste the following configuration in the standard Hermes configuration file at <code>~/.hermes/config.toml</code>:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[[chains]]
id = 'ibc-0'
rpc_addr = 'http://127.0.0.1:26657'
grpc_addr = 'http://127.0.0.1:9090'
websocket_addr = 'ws://127.0.0.1:26657/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
max_gas = 2000000
gas_price = { price = 0.001, denom = 'stake' }
gas_adjustment = 0.1
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }

[[chains]]
id = 'ibc-1'
rpc_addr = 'http://127.0.0.1:26557'
grpc_addr = 'http://127.0.0.1:9091'
websocket_addr = 'ws://127.0.0.1:26557/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
max_gas = 2000000
gas_price = { price = 0.001, denom = 'stake' }
gas_adjustment = 0.1
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }

[[chains]]
id = 'ibc-2'
rpc_addr = 'http://127.0.0.1:26457'
grpc_addr = 'http://127.0.0.1:9092'
websocket_addr = 'ws://127.0.0.1:26457/websocket'
rpc_timeout = '10s'
account_prefix = 'cosmos'
key_name = 'testkey'
store_prefix = 'ibc'
max_gas = 2000000
gas_price = { price = 0.001, denom = 'stake' }
gas_adjustment = 0.1
clock_drift = '5s'
trusting_period = '14days'
trust_threshold = { numerator = '1', denominator = '3' }
</code></pre>
<p>This configuration has three chains <code>ibc-0</code>, <code>ibc-1</code> and <code>ibc-2</code>.</p>
</li>
<li>
<p>Run the <code>dev-env</code> script with the parameters below to start three chains:</p>
<pre><code class="language-bash">./scripts/dev-env ~/.hermes/config.toml ibc-0 ibc-1 ibc-2
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: The script will prompt you to delete the data folder, double check the path and
if it points to the <code>data</code> directory in the current directory, answer <strong>'yes'</strong>.</p>
</blockquote>
<p>The script configures and starts three <strong><code>gaiad</code></strong> instances, named <strong><code>ibc-0</code></strong>, and <strong><code>ibc-1</code></strong>, and <strong><code>ibc-2</code></strong>.</p>
</li>
<li>
<p>Create a channel between <code>ibc-0</code> and <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes create channel ibc-0 ibc-1 --port-a transfer --port-b transfer -o unordered
</code></pre>
<pre><code class="language-json">(...)

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}
</code></pre>
<p>Note that the channel identifier on both <code>ibc-0</code> and <code>ibc-1</code> is <code>channel-0</code>.</p>
</li>
<li>
<p>Create a channel between <code>ibc-1</code> and <code>ibc-2</code>:</p>
<pre><code class="language-shell">hermes create channel ibc-1 ibc-2 --port-a transfer --port-b transfer -o unordered
</code></pre>
<pre><code class="language-json">(...)

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-2&quot;,
                version: 2,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
    version: Some(
        &quot;ics20-1&quot;,
    ),
}
</code></pre>
<p>Note that the channel identifier on <code>ibc-1</code> is <code>channel-1</code>, and on <code>ibc-2</code> it is <code>channel-0</code>.</p>
</li>
<li>
<p>Start Hermes using the <code>start</code> command:</p>
<pre><code class="language-shell">hermes start
</code></pre>
<p>Hermes will first relay the pending packets that have not been relayed and then
start passive relaying by listening to and acting on packet events.</p>
</li>
<li>
<p>In a separate terminal, use the <code>ft-transfer</code> command to send:</p>
<ul>
<li>
<p>Two packets from <code>ibc-0</code> to <code>ibc-1</code> from source channel <code>channel-0</code></p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 -o 1000 -n 2
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: revision: 0, height: 3056,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(3),
        },
    ),
    SendPacket(
        SendPacket {
            height: revision: 0, height: 3056,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
]
</code></pre>
</li>
<li>
<p>Two packets from <code>ibc-1</code> to <code>ibc-2</code> from source channel <code>channel-1</code></p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-2 ibc-1 transfer channel-1 9999 -o 1000 -n 2
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: revision: 1, height: 3076,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(3),
        },
    ),
    SendPacket(
        SendPacket {
            height: revision: 1, height: 3076,
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-1&quot;) Sequence(4),
        },
    ),
]
</code></pre>
</li>
</ul>
</li>
<li>
<p>Observe the output on the relayer terminal, verify that the send events are processed, and that the <code>recv_packets</code> are sent out.</p>
<pre><code class="language-text">(...)

INFO ibc_relayer::link: [ibc-0 -&gt; ibc-1] result events:
    UpdateClientEv(ev_h:1-3048, 07-tendermint-0(0-3057), )
    WriteAcknowledgementEv(h:1-3048, seq:3, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
    WriteAcknowledgementEv(h:1-3048, seq:4, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
INFO ibc_relayer::link: [ibc-0 -&gt; ibc-1] success

(...)

INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] clearing old packets
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] received from query_txs []
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] finished clearing pending packets
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] generate messages from batch with 2 events
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] scheduling op. data with 2 msg(s) for Destination chain (height 1-3049)
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] relay op. data to Destination, proofs height 1-3048, (delayed by: 2.154603ms) [try 1/10]
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] prepending Destination client update @ height 1-3049
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] assembled batch of 3 message(s)
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] result events:
    UpdateClientEv(ev_h:0-3059, 07-tendermint-0(1-3049), )
    AcknowledgePacketEv(h:0-3059, seq:3, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
    AcknowledgePacketEv(h:0-3059, seq:4, path:channel-0/transfer-&gt;channel-0/transfer, toh:1-4045, tos:0))
INFO ibc_relayer::link: [ibc-1 -&gt; ibc-0] success

(...)
</code></pre>
</li>
<li>
<p>Query the unreceived packets and acknowledgments on <code>ibc-1</code> and <code>ibc-2</code> from a different terminal:</p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 transfer channel-0
hermes query packet unreceived-acks ibc-0 transfer channel-0
hermes query packet unreceived-packets ibc-2 transfer channel-0
hermes query packet unreceived-acks ibc-1 transfer channel-1
</code></pre>
<p>If everything went well, each of these commands should result in:</p>
<pre><code>Success: []
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-the-chains"><a class="header" href="#connecting-the-chains">Connecting the chains</a></h1>
<p>In the rest of this section we will show how to create the clients, establish a connection and a channel between the two chains, and relay packets over the channel. But first, make sure you followed the steps in the <a href="tutorials/local-chains/raw/../start.html">start the local chains</a> and <a href="tutorials/local-chains/raw/../identifiers.html">Identifiers section</a></p>
<h2 id="steps-to-start-relaying-packets-between-the-two-local-chains"><a class="header" href="#steps-to-start-relaying-packets-between-the-two-local-chains">Steps to start relaying packets between the two local chains</a></h2>
<p>In order to start relaying packets please follow the steps below:</p>
<ul>
<li><a href="tutorials/local-chains/raw/./client.html">Configure Clients</a></li>
<li><a href="tutorials/local-chains/raw/./connection.html">Connection Handshake</a></li>
<li><a href="tutorials/local-chains/raw/./channel.html">Open the Channel</a></li>
<li><a href="tutorials/local-chains/raw/./packet.html">Relay Packets</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-configuring-clients"><a class="header" href="#1-configuring-clients">1. Configuring clients</a></h1>
<h3 id="11-create-client"><a class="header" href="#11-create-client">1.1. <code>create client</code></a></h3>
<p>First you will need to create a client for each chain:</p>
<p>This command submits a transaction to a destination chain (<code>ibc-0</code>) with a request to create a client for a source chain (<code>ibc-1</code>):</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-0 ibc-1
</code></pre>
<p>if the command is successful a message similar to the one below will be displayed <code>status:success</code>:</p>
<pre><code class="language-json">{
    Success: CreateClient(
        CreateClient(
            Attributes {
                height: Height { revision: 0, height: 43 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 1, height: 32 },
            },
        ),
    )
}
</code></pre>
<blockquote>
<p>Please note the <code>client_id</code> value returned. You will need that for other commands.</p>
</blockquote>
<p>You can also execute a <strong>query</strong> to view the client state on destination chain <code>ibc-0</code> by specifying the <code>client_id</code> value <code>07-tendermint-0</code>:</p>
<pre><code class="language-shell">hermes query client state ibc-0 07-tendermint-0
</code></pre>
<p>which show a message similar to the one below:</p>
<pre><code class="language-json">Success: ClientState {
    chain_id: ChainId {
        id: &quot;ibc-1&quot;,
        version: 1,
    },
    trust_level: TrustThresholdFraction {
        numerator: 1,
        denominator: 3,
    },
    trusting_period: 1209600s,
    unbonding_period: 1814400s,
    max_clock_drift: 3s,
    frozen_height: Height {
        revision: 0,
        height: 0,
    },
    latest_height: Height {
        revision: 1,
        height: 38,
    },
    upgrade_path: [
        &quot;upgrade&quot;,
        &quot;upgradedIBCState&quot;,
    ],
    allow_update_after_expiry: true,
    allow_update_after_misbehaviour: true,
}
</code></pre>
<p>Now let's do the same for <code>ibc-1</code> as the destination chain:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-1 ibc-0
</code></pre>
<p>Take note of the <code>client_id</code> allocated for this client. In the examples we assume is <code>07-tendermint-1</code> (this client identity is obtained by creating two clients on ibc-1 for ibc-0).</p>
<p>As before, if the command is successful a message with <code>status:success</code> is displayed:</p>
<pre><code class="language-json">Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height {
                revision: 1,
                height: 135,
            },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 0,
                height: 145,
            },
        },
    ),
)
</code></pre>
<h3 id="12-update-client"><a class="header" href="#12-update-client">1.2 <code>update-client</code></a></h3>
<p>Client states can be updated by sending an <code>update-client</code> transaction:</p>
<pre><code class="language-shell">hermes tx raw update-client ibc-0 07-tendermint-0
</code></pre>
<pre><code class="language-shell">hermes tx raw update-client ibc-1 07-tendermint-1
</code></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>In the next section, we'll establish the <a href="tutorials/local-chains/raw/./connection.html">Connection Handshake</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-connection-handshake"><a class="header" href="#2-connection-handshake">2. Connection Handshake</a></h1>
<h2 id="21-conn-init"><a class="header" href="#21-conn-init">2.1 <code>conn-init</code></a></h2>
<p>Initialize a new connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-1
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>connection-0</code> on <code>ibc-0</code> in order to use it in the <code>conn-try</code> command below.</p>
<h2 id="22-conn-try"><a class="header" href="#22-conn-try">2.2 <code>conn-try</code></a></h2>
<p>Send a connection try to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-try ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -s connection-0
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>connection-1</code> on <code>ibc-1</code>. Use in the <code>conn-ack</code> CLI</p>
<h2 id="23-conn-ack"><a class="header" href="#23-conn-ack">2.3 <code>conn-ack</code></a></h2>
<p>Send a connection open acknowledgment to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-ack ibc-0 ibc-1 07-tendermint-0 07-tendermint-1 -d connection-0 -s connection-1
</code></pre>
<h2 id="24-conn-confirm"><a class="header" href="#24-conn-confirm">2.4 <code>conn-confirm</code></a></h2>
<p>Send the open confirmation to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-confirm ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -d connection-1 -s connection-0
</code></pre>
<h2 id="25-query-connection"><a class="header" href="#25-query-connection">2.5 <code>query connection</code></a></h2>
<p>To verify that the two ends are in <code>Open</code> state:</p>
<pre><code class="language-shell">hermes query connection end ibc-0 connection-0
</code></pre>
<pre><code class="language-shell">hermes query connection end ibc-1 connection-1
</code></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>In the next section, we'll <a href="tutorials/local-chains/raw/./channel.html">establish a new channel</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-channel-handshake"><a class="header" href="#3-channel-handshake">3. Channel Handshake</a></h1>
<h2 id="31-chan-open-init"><a class="header" href="#31-chan-open-init">3.1 <code>chan-open-init</code></a></h2>
<p>Initialize a new unordered channel on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-0 ibc-1 connection-0 transfer transfer -o UNORDERED
</code></pre>
<h2 id="32-chan-open-try"><a class="header" href="#32-chan-open-try">3.2 <code>chan-open-try</code></a></h2>
<p>Send a channel open try to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-try ibc-1 ibc-0 connection-1 transfer transfer -s channel-0
</code></pre>
<p>Take note of the ID allocated by the chain, e.g. <code>channel-1</code> on <code>ibc-1</code>. Use in the <code>chan-open-ack</code> CLI</p>
<h2 id="33-chan-open-ack"><a class="header" href="#33-chan-open-ack">3.3 <code>chan-open-ack</code></a></h2>
<p>Send a channel open acknowledgment to <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-ack ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<h2 id="34-chan-open-confirm"><a class="header" href="#34-chan-open-confirm">3.4 <code>chan-open-confirm</code></a></h2>
<p>Send the open confirmation to <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<h2 id="35-query-channel"><a class="header" href="#35-query-channel">3.5 <code>query channel</code></a></h2>
<p>To verify that the two ends are in <code>Open</code> state:</p>
<pre><code class="language-shell">hermes query channel end ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-shell">hermes query channel end ibc-1 transfer channel-1
</code></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>In the next section, we'll start to <a href="tutorials/local-chains/raw/./packet.html">relay packets</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-relay-packets"><a class="header" href="#4-relay-packets">4. Relay Packets</a></h1>
<h3 id="41-query-balances"><a class="header" href="#41-query-balances">4.1 Query balances</a></h3>
<ul>
<li>
<p>balance at ibc-0</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:26657 query bank balances $(gaiad --home data/ibc-0 keys --keyring-backend=&quot;test&quot; show user -a)
</code></pre>
</li>
<li>
<p>balance at ibc-1</p>
<pre><code class="language-shell">gaiad --node tcp://localhost:26557 query bank balances $(gaiad --home data/ibc-1 keys --keyring-backend=&quot;test&quot; show user -a)
</code></pre>
</li>
</ul>
<blockquote>
<p>Note that the addresses used in the two commands above are configured in <code>dev-env</code>.</p>
</blockquote>
<h3 id="42-packet-relaying"><a class="header" href="#42-packet-relaying">4.2 Packet relaying</a></h3>
<p>First, we'll send <code>9999</code> <code>samoleans</code> from <code>ibc-0</code> to <code>ibc-1</code>.</p>
<ul>
<li>
<p>start the transfer of 9999 samoleans from <code>ibc-0</code> to <code>ibc-1</code>. This sends a <code>MsgTransfer</code> in a transaction to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 -o 1000 -n 1 -d samoleans
</code></pre>
</li>
<li>
<p>query packet commitments on <code>ibc-0</code></p>
<pre><code class="language-shell">hermes query packet commitments ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>query unreceived packets on <code>ibc-1</code></p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>send <code>recv_packet</code> to <code>ibc-1</code></p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>query unreceived acks on <code>ibc-0</code></p>
<pre><code class="language-shell">hermes query packet unreceived-acks ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>send acknowledgement to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw packet-ack ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
</ul>
<p>Send those samoleans back, from <code>ibc-1</code> to <code>ibc-0</code>.</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 9999 -o 1000 -n 1 -d ibc/49D321B40FCF56B0370E5673CF090389C8E9CD185209FBE1BEE5D94E58E69BDC
hermes tx raw packet-recv ibc-0 ibc-1 transfer channel-1
hermes tx raw packet-ack  ibc-1 ibc-0 transfer channel-0
</code></pre>
<p>The <code>ibc/49D321B40FCF56B0370E5673CF090389C8E9CD185209FBE1BEE5D94E58E69BDC</code> denominator above can be obtained by querying the balance at <code>ibc-1</code> after the transfer from <code>ibc-0</code> to <code>ibc-1</code> is concluded.</p>
<p>Next we will test the packet timeouts.</p>
<ul>
<li>
<p>send 1 packet with low timeout height offset to ibc-0</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 -o 2 -n 1
</code></pre>
</li>
<li>
<p>send timeout to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
<li>
<p>send 1 packet with 2 second timeout to ibc-0</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 -t 2 -n 1
</code></pre>
</li>
<li>
<p>send timeout to <code>ibc-0</code></p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The <code>Commands</code> section presents the commands current available in Hermes</p>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<p><strong><a href="commands/./keys/index.html">Keys</a></strong></p>
<p>Commands to manage keys (private keys) for each chain.</p>
<p><strong><a href="commands/./config.html">Config</a></strong></p>
<p>Commands to manage configuration file, in particular to validate it.</p>
<p><strong><a href="commands/./path-setup/index.html">Path Setup</a></strong></p>
<p>Commands to manage clients, connections, channels.</p>
<p><strong><a href="commands/./relaying/index.html">Relaying</a></strong></p>
<p>Commands to start the relayer and relay packets.</p>
<p><strong><a href="commands/./listen/index.html">Listen Mode</a></strong></p>
<p>Commands to listen for IBC events</p>
<p><strong><a href="commands/./upgrade/index.html">Upgrade</a></strong></p>
<p>Commands to perform client upgrade</p>
<p><strong><a href="commands/./misbehaviour/index.html">Monitor</a></strong></p>
<p>Commands to monitor clients and submit evidence of misbehaviour</p>
<p><strong><a href="commands/./queries/index.html">Queries</a></strong></p>
<p>Commands to execute queries on configured chains</p>
<p><strong><a href="commands/./raw/index.html">Raw Transactions</a></strong></p>
<p>Commands to submit individual transactions to configured chains</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-options"><a class="header" href="#global-options">Global options</a></h1>
<p>Hermes accepts global options which affect all commands.</p>
<pre><code class="language-shell">hermes 0.11.1
Informal Systems &lt;hello@informal.systems&gt;
Implementation of `hermes`, an IBC Relayer developed in Rust.

FLAGS:
    -c, --config CONFIG       path to configuration file
    -j, --json                enable JSON output
</code></pre>
<p>The flags must be specified right after the <code>hermes</code> command and before any subcommand.</p>
<p><strong>Example</strong></p>
<p>To start the relayer using the configuration file at <code>/home/my_chain.toml</code> and enable JSON output:</p>
<pre><code class="language-shell">hermes -c /home/my_chain.toml --json start
</code></pre>
<h2 id="json-output"><a class="header" href="#json-output">JSON output</a></h2>
<p>If the <code>--json</code> option is supplied, all relayer commands will output single-line JSON values instead of plain text.</p>
<p>Log messages will be written to <code>stderr</code>, while the final result will be written to <code>stdout</code>, and everything
will be formatted as JSON.
This allows processing only the final output using <a href="https://stedolan.github.io/jq/"><code>jq</code></a>.
To process all the output using <code>jq</code>, one can redirect <code>stderr</code> to <code>stdout</code> with <code>hermes --json COMMAND 2&gt;&amp;1 | jq</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes -c /home/my_chain.toml --json create client ibc-0 ibc-1
</code></pre>
<pre><code class="language-json">{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.921&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Using default configuration from: '.hermes/config.toml'&quot;},&quot;target&quot;:&quot;ibc_relayer_cli::commands&quot;}
{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.961&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-1&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;timestamp&quot;:&quot;Apr 13 20:46:31.989&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;running listener&quot;,&quot;chain.id&quot;:&quot;ibc-0&quot;},&quot;target&quot;:&quot;ibc_relayer::event::monitor&quot;}
{&quot;result&quot;:{&quot;CreateClient&quot;:{&quot;client_id&quot;:&quot;07-tendermint-1&quot;,&quot;client_type&quot;:&quot;Tendermint&quot;,&quot;consensus_height&quot;:{&quot;revision_height&quot;:10060,&quot;revision_number&quot;:1},&quot;height&quot;:{&quot;revision_height&quot;:10072,&quot;revision_number&quot;:0}}},&quot;status&quot;:&quot;success&quot;}
</code></pre>
<p>The first three lines are printed to <code>stderr</code>, while the last line with a <code>&quot;result&quot;</code> key is printed to <code>stdout</code>.</p>
<p><strong>Example</strong></p>
<p>To improve the readability, pipe all of the output to <code>jq</code>:</p>
<pre><code>hermes -c /home/my_chain.toml --json create client ibc-0 ibc-1 2&gt;&amp;1 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.060&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;Using default configuration from: '.hermes/config.toml'&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer_cli::commands&quot;
}
{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.082&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;running listener&quot;,
    &quot;chain.id&quot;: &quot;ibc-1&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer::event::monitor&quot;
}
{
  &quot;timestamp&quot;: &quot;Apr 13 20:52:26.088&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;running listener&quot;,
    &quot;chain.id&quot;: &quot;ibc-0&quot;
  },
  &quot;target&quot;: &quot;ibc_relayer::event::monitor&quot;
}
{
  &quot;result&quot;: {
    &quot;CreateClient&quot;: {
      &quot;client_id&quot;: &quot;07-tendermint-5&quot;,
      &quot;client_type&quot;: &quot;Tendermint&quot;,
      &quot;consensus_height&quot;: {
        &quot;revision_height&quot;: 10364,
        &quot;revision_number&quot;: 1
      },
      &quot;height&quot;: {
        &quot;revision_height&quot;: 10375,
        &quot;revision_number&quot;: 0
      }
    }
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<p><strong>Example</strong></p>
<p>To extract the identifer of the newly created client above:</p>
<pre><code>hermes -c /home/my_chain.toml --json create client ibc-0 ibc-1 | jq '.result.CreateClient.client_id'
</code></pre>
<pre><code>&quot;07-tendermint-2&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-keys-to-the-relayer"><a class="header" href="#adding-keys-to-the-relayer">Adding Keys to the Relayer</a></h1>
<blockquote>
<p><strong>WARNING</strong>: Currently the relayer does NOT support a <code>keyring</code> store to securely
store the private key file. The key file will be stored on the local file system
in the user <strong>$HOME</strong> folder under <code>$HOME/.hermes/keys/</code></p>
</blockquote>
<blockquote>
<p><strong>BREAKING</strong>: As of Hermes v0.2.0, the format of the keys stored on disk has changed, and
keys which had been previously configured must now be re-imported using either the <code>keys add</code>
or the <code>keys restore</code> commands.</p>
</blockquote>
<hr />
<p>Using the <code>keys</code> command you can add and list keys. </p>
<h4 id="show-usage"><a class="header" href="#show-usage">Show usage</a></h4>
<p>To see the available sub-commands for the <code>keys</code> command run:</p>
<pre><code class="language-shell">hermes help keys
</code></pre>
<p>Currently there are two sub-commands supported <code>add</code> and <code>list</code>:</p>
<pre><code class="language-shell">USAGE:
    hermes keys &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Manage keys in the relayer for each chain

SUBCOMMANDS:
    help       Get usage information
    add        Adds a key to a configured chain
    delete     Delete key(s) from a configured chain
    list       List keys configured on a chain
    restore    restore a key to a configured chain using a mnemonic
</code></pre>
<h3 id="key-seed-file-private-key"><a class="header" href="#key-seed-file-private-key">Key Seed file (Private Key)</a></h3>
<p>In order to execute the command below you need a private key file (JSON). The relayer uses the private key file to sign the transactions submitted to the chain.</p>
<p>The private key file can be obtained by using the <code>keys add</code> on a Cosmos chain, for example for a <code>gaia</code> chain the command is:</p>
<pre><code class="language-shell">gaiad keys add ...
</code></pre>
<p>The command outputs a JSON similar to the one below. You can save this file (e.g. <code>key_seed.json</code>) and use it to add to the relayer</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;user&quot;,
  &quot;type&quot;: &quot;local&quot;,
  &quot;address&quot;: &quot;cosmos1tc3vcuxyyac0dmayf887t95tdg7qpyql48w7gj&quot;,
  &quot;pubkey&quot;: &quot;cosmospub1addwnpepqgg7ng4ycm60pdxfzdfh4hjvkwcr3da59mr8k883vsstx60ruv7kur4525u&quot;,
  &quot;mnemonic&quot;: &quot;[24 words mnemonic]&quot;
}
</code></pre>
<h3 id="adding-keys"><a class="header" href="#adding-keys">Adding Keys</a></h3>
<h4 id="add-a-private-key-to-a-chain-from-a-key-file"><a class="header" href="#add-a-private-key-to-a-chain-from-a-key-file">Add a private key to a chain from a key file</a></h4>
<pre><code class="language-shell">    hermes keys add &lt;OPTIONS&gt;

DESCRIPTION:
    Adds a key to a configured chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain

FLAGS:
    -f, --file FILE           path to the key file
    -n, --name NAME           name of the key (defaults to the `key_name` defined in the config)
    -p, --hd-path HD-PATH     derivation path for this key (default: m/44'/118'/0'/0/0)
</code></pre>
<p>To add a private key file to a chain:</p>
<pre><code class="language-shell">hermes -c config.toml keys add [CHAIN_ID] -f [PRIVATE_KEY_FILE]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Added key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<blockquote>
<p><strong>Key name:</strong>
By default, the key will be named after the <code>key_name</code> property specified in the configuration file.
To use a different key name, specify the <code>--name</code> option when invoking <code>keys add</code>.</p>
<pre><code>hermes -c config.toml keys add [CHAINID] -f [PRIVATE_KEY_FILE] -n [KEY_NAME]
</code></pre>
</blockquote>
<h4 id="restore-a-private-key-to-a-chain-from-a-mnemonic"><a class="header" href="#restore-a-private-key-to-a-chain-from-a-mnemonic">Restore a private key to a chain from a mnemonic</a></h4>
<pre><code class="language-shell">USAGE:
    hermes keys restore &lt;OPTIONS&gt;

DESCRIPTION:
    restore a key to a configured chain using a mnemonic

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain

FLAGS:
    -m, --mnemonic MNEMONIC   mnemonic to restore the key from
    -n, --name NAME           name of the key (defaults to the `key_name` defined in the config)
    -p, --hd-path HD-PATH     derivation path for this key (default: m/44'/118'/0'/0/0)
</code></pre>
<p>To restore a key from its mnemonic:</p>
<pre><code class="language-shell">hermes -c config.toml keys restore [CHAIN_ID] -m &quot;[MNEMONIC]&quot;
</code></pre>
<p>or using an explicit <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">derivation path</a>, for example
an Ethereum coin type (used for Evmos, Injective, Umee, Cronos, and
possibly other networks):</p>
<pre><code class="language-shell">hermes -c config.toml keys restore --mnemonic &lt;MNEMONIC&gt; --hd-path &quot;m/44'/60'/0'/0/0&quot; &lt;CHAIN_ID&gt;
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">Success: Restore key testkey ([ADDRESS]) on [CHAIN ID] chain
</code></pre>
<blockquote>
<p><strong>Key name:</strong>
By default, the key will be named after the <code>key_name</code> property specified in the configuration file.
To use a different key name, specify the <code>--name</code> option when invoking <code>keys restore</code>.</p>
<pre><code>hermes -c config.toml keys restore [CHAINID] -m &quot;[MNEMONIC]&quot; -n [KEY_NAME]
</code></pre>
</blockquote>
<h3 id="delete-keys"><a class="header" href="#delete-keys">Delete keys</a></h3>
<p>In order to delete the private keys added to chains use the <code>keys delete</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys delete &lt;OPTIONS&gt;

DESCRIPTION:
    Delete key(s) from a configured chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain

FLAGS:
    -n, --name NAME           name of the key
    -a, --all                 delete all keys
</code></pre>
<h4 id="delete-private-keys-that-was-previously-added-to-a-chain"><a class="header" href="#delete-private-keys-that-was-previously-added-to-a-chain">Delete private keys that was previously added to a chain</a></h4>
<p>To delete a single private key by name:</p>
<pre><code class="language-shell">hermes -c config.toml keys delete [CHAIN_ID] -n [KEY_NAME]
</code></pre>
<p>Alternatively, to delete all private keys added to a chain:</p>
<pre><code class="language-shell">hermes -c config.toml keys delete [CHAIN_ID] -a
</code></pre>
<h3 id="list-keys"><a class="header" href="#list-keys">List keys</a></h3>
<p>In order to list the private keys added to chains use the <code>keys list</code> command</p>
<pre><code class="language-shell">USAGE:
    hermes keys list &lt;OPTIONS&gt;

DESCRIPTION:
    List keys configured on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain
</code></pre>
<h4 id="listing-the-private-key-that-was-added-to-a-chain"><a class="header" href="#listing-the-private-key-that-was-added-to-a-chain">Listing the private key that was added to a chain</a></h4>
<p>To list the private key file that was added to a chain:</p>
<pre><code class="language-shell">hermes -c config.toml keys list [CHAIN_ID]
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code>Success:
- user2 (cosmos1attn9fxrcvjz483w3tu4cfz77ldmlyujly3q3k)
- testkey (cosmos1dw88vdekeeuta5u50p6n5lt5v5c6y2we0pu8nz)
</code></pre>
<p><strong>JSON:</strong></p>
<pre><code class="language-shell">hermes --json -c config.toml keys list [CHAIN_ID] | jq
</code></pre>
<p>If the command is successful a message similar to the one below will be displayed:</p>
<pre><code class="language-json">{
  &quot;result&quot;: {
    &quot;testkey&quot;: {
      &quot;account&quot;: &quot;cosmos1dw88vdekeeuta5u50p6n5lt5v5c6y2we0pu8nz&quot;,
      &quot;address&quot;: [ 107, 142, 118, 55, 54, 206, 120, 190, 211, 148, 120, 117, 58, 125, 116, 101, 49, 162, 41, 217 ],
      &quot;coin_type&quot;: 118,
      &quot;private_key&quot;: &quot;(snip)&quot;,
      &quot;public_key&quot;: &quot;xpub6Gc7ZUt2q1BiQYjhUextPv5bZLwosHigZYqEquPD6FkAGmHDrLiBgE5Xnh8XGZp79rAXtZn1Dt3DNQHxxgCgVQqfRMfVsRiXn6mwULBnYq7&quot;
    },
    &quot;user2&quot;: {
      &quot;account&quot;: &quot;cosmos1attn9fxrcvjz483w3tu4cfz77ldmlyujly3q3k&quot;,
      &quot;address&quot;: [ 234, 215, 50, 164, 195, 195, 36, 42, 158, 46, 138, 249, 92, 36, 94, 247, 219, 191, 147, 146 ],
      &quot;coin_type&quot;: 118,
      &quot;private_key&quot;: &quot;(snip)&quot;,
      &quot;public_key&quot;: &quot;xpub6FmDbeGTWVjSvHrqHfrpnMTZxpPX1V7XFiq5nMuvgwX9jumt1yUuwNAUQo8Nn36unbFShg6iSjkfMBgeY49wik7rF91N2SHvarpX62ByWMf&quot;
    }
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="config"><a class="header" href="#config">Config</a></h1>
<p>Use the <code>config validate</code> command to perform a quick syntactic validation of
your configuration file.</p>
<pre><code class="language-shell">USAGE:
    hermes config validate &lt;OPTIONS&gt;

DESCRIPTION:
    validate the relayer configuration
</code></pre>
<p><strong>Example</strong></p>
<p>Validate the default config file, the path inferred automatically to be
<code>$HOME/.hermes/config.toml</code>.</p>
<pre><code class="language-shell">hermes config validate
</code></pre>
<pre><code class="language-text">hermes config validate
Jul 12 16:31:07.017  INFO using default configuration from '$HOME/.hermes/config.toml'
Success: &quot;validation passed successfully&quot;
</code></pre>
<p>Validate a config file at an arbitrary location:</p>
<pre><code class="language-shell">hermes -c ./config.toml config validate
</code></pre>
<p>This one fails validation because we mistakenly added two separate sections for
the same chain <code>ibc-1</code>:</p>
<pre><code class="language-text">hermes -c ./config.toml  config validate
error: hermes fatal error: config error: config file has duplicate entry for the chain with id ibc-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-setup"><a class="header" href="#path-setup">Path Setup</a></h1>
<p>This section describes a number of commands that can be used to manage clients, connections, channels.</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create client</code></td><td><a href="commands/path-setup/./clients.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update client</code></td><td><a href="commands/path-setup/./clients.html#md-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>create connection</code></td><td><a href="commands/path-setup/./connections.html#establish-connection">Establish a connection using existing or new clients</a></td></tr>
<tr><td><code>create channel</code></td><td><a href="commands/path-setup/./channels.html#establish-channel">Establish a channel using existing or new connection</a></td></tr>
</tbody></table>
<h2 id="create"><a class="header" href="#create">Create</a></h2>
<p>Use the <code>create</code> commands to create new clients, connections and channels.</p>
<pre><code class="language-shell">USAGE:
    hermes create &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Create objects (client, connection, or channel) on chains

SUBCOMMANDS:
    help       Get usage information
    client     Create a new IBC client
    connection Create a new connection between two chains
    channel    Create a new channel between two chains
</code></pre>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>Use the <code>update</code> commands to update a client.</p>
<pre><code class="language-shell">USAGE:
    hermes update &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Update objects (clients) on chains

SUBCOMMANDS:
    help       Get usage information
    client     Update an IBC client
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="commands/path-setup/clients.html#create-client">Create Client</a></li>
<li><a href="commands/path-setup/clients.html#update-client">Update Client</a></li>
</ul>
<h2 id="create-client"><a class="header" href="#create-client">Create Client</a></h2>
<p>Use the <code>create client</code> command to create a new client.</p>
<pre><code class="language-shell">USAGE:
    hermes create client &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new IBC client

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client of <code>ibc-1</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes create client ibc-0 ibc-1
</code></pre>
<pre><code class="language-json">    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 286,
            },
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 274,
            },
        },
    ),
)
</code></pre>
<p>A new client is created with identifier <code>07-tendermint-1</code></p>
<h2 id="update-client"><a class="header" href="#update-client">Update Client</a></h2>
<p>Use the <code>update client</code> command to update an existing client with a new consensus state.
Specific update and trusted heights can be specified.</p>
<pre><code class="language-shell">USAGE:
    hermes update client &lt;OPTIONS&gt;

DESCRIPTION:
    Update an IBC client

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    dst_client_id             identifier of the client to be updated on destination chain

FLAGS:
    -H, --target-height TARGET-HEIGHT
    -t, --trusted-height TRUSTED-HEIGHT
</code></pre>
<p><strong>Update client with latest header</strong></p>
<p>the client on <code>ibc-0</code> with latest header of <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes update client ibc-0 07-tendermint-9
</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 303 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 293 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-293</code>.</p>
<p><strong>Update a client to a specific target height</strong></p>
<pre><code class="language-shell">hermes update client ibc-0 07-tendermint-1 --target-height 320 --trusted-height 293
</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 555 },
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 320 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-1</code> has been updated with the consensus state at height <code>1-320</code>, as specified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection"><a class="header" href="#connection">Connection</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="commands/path-setup/connections.html#establish-connection">Establish Connection</a></li>
<li><a href="commands/path-setup/connections.html#examples">Examples</a>
<ul>
<li><a href="commands/path-setup/connections.html#new-connection-over-new-clients">New connection over new clients</a></li>
<li><a href="commands/path-setup/connections.html#new-connection-over-existing-clients">New connection over existing clients</a></li>
</ul>
</li>
<li><a href="commands/path-setup/connections.html#non-zero-delay-connection">Non-zero Delay Connection</a></li>
</ul>
<h2 id="establish-connection"><a class="header" href="#establish-connection">Establish Connection</a></h2>
<p>Use the <code>create connection</code> command to create a new connection.</p>
<pre><code class="language-shell">USAGE:
    hermes create connection &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new connection between two chains

POSITIONAL ARGUMENTS:
    chain_a_id                identifier of the side `a` chain for the new connection
    chain_b_id                identifier of the side `b` chain for the new connection

FLAGS:
    --client-a CLIENT-A       identifier of client hosted on chain `a`; default: None (creates a new client)
    --client-b CLIENT-B       identifier of client hosted on chain `b`; default: None (creates a new client)
    --delay DELAY             delay period parameter for the new connection (seconds) (default: 0)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="new-connection-over-new-clients"><a class="header" href="#new-connection-over-new-clients">New connection over new clients</a></h3>
<p>Create a new connection between <code>ibc-0</code> and <code>ibc-1</code> over new clients:</p>
<pre><code class="language-shell">hermes create connection ibc-0 ibc-1
</code></pre>
<pre><code class="language-json">🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 4069 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 4081 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 4073 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-8&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-8&quot;,
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
}]

Success: Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-8&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-8&quot;,
        ),
    },
}
</code></pre>
<h3 id="new-connection-over-existing-clients"><a class="header" href="#new-connection-over-existing-clients">New connection over existing clients</a></h3>
<p>Create a new connection between <code>ibc-0</code> and <code>ibc-1</code> over existing clients,
both with client id <code>07-tendermint-0</code>:</p>
<pre><code class="language-shell">hermes create connection ibc-0 --client-a 07-tendermint-0 --client-b
07-tendermint-0
</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given client on <code>ibc-0</code>.</p>
<h2 id="non-zero-delay-connection"><a class="header" href="#non-zero-delay-connection">Non-zero Delay Connection</a></h2>
<p>A connection can be created with a delay period parameter. This parameter specifies a period of time that must elpase after a successful client state update and before a packet with proofs using its commitment root can pe processed on chain. For more information see <a href="commands/path-setup/../relaying/index.html#packet-delay">how packet delay works</a> and the <a href="https://github.com/cosmos/ibc/tree/master/spec/core/ics-003-connection-semantics">connection delay specification</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel"><a class="header" href="#channel">Channel</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="commands/path-setup/channels.html#establish-channel">Establish Channel</a></li>
<li><a href="commands/path-setup/channels.html#examples">Examples</a>
<ul>
<li><a href="commands/path-setup/channels.html#new-channel-over-a-new-connection">New channel over a new connection</a></li>
<li><a href="commands/path-setup/channels.html#new-channel-over-an-existing-connection">New channel over an existing connection</a></li>
</ul>
</li>
</ul>
<h2 id="establish-channel"><a class="header" href="#establish-channel">Establish Channel</a></h2>
<p>Use the <code>create channel</code> command to establish a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes create channel &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new channel between two chains

POSITIONAL ARGUMENTS:
    chain_a_id                identifier of the side `a` chain for the new channel
    chain_b_id                identifier of the side `b` chain for the new channel (optional)

FLAGS:
    -c, --connection-a CONNECTION-A
    --port-a PORT-A           identifier of the side `a` port for the new channel
    --port-b PORT-B           identifier of the side `b` port for the new channel
    -o, --order ORDER         the channel ordering, valid options 'unordered' (default) and 'ordered'
    -v, --channel-version VERSION     the version for the new channel
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="new-channel-over-a-new-connection"><a class="header" href="#new-channel-over-a-new-connection">New channel over a new connection</a></h3>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over a new connection, using
port name <code>transfer</code> on both sides:</p>
<pre><code class="language-shell">hermes create channel ibc-0 ibc-1 --port-a transfer --port-b transfer -o unordered
</code></pre>
<pre><code class="language-json">🥂  ibc-0 =&gt; OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 66 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 64 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-0 =&gt; OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 76 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂  ibc-1 =&gt; OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 68 },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)

🥂🥂🥂  Connection handshake finished for [Connection {
    delay_period: 0s,
    a_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
    },
    b_side: ConnectionSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
    },
}]

🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 78 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: None
        }
    )
)

🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 70 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 81 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  ibc-1 =&gt; OpenConfirmChannel
    OpenConfirm
        Attributes {
            height: Height { revision: 1, height: 73 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-0&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-0&quot;))
        }
    )
)

🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
}

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
    },
    connection_delay: 0s,
}
</code></pre>
<p>A new channel with identifier <code>channel-0</code> on both sides has been established on
a new connection with identifier <code>connection-0</code> on both sides.</p>
<h3 id="new-channel-over-an-existing-connection"><a class="header" href="#new-channel-over-an-existing-connection">New channel over an existing connection</a></h3>
<p>Create a new unordered channel between <code>ibc-0</code> and <code>ibc-1</code> over an existing connection,
specifically the one we just created in the example above, with port name <code>transfer</code> on both sides:</p>
<pre><code class="language-shell">hermes create channel ibc-0 --connection-a connection-0 --port-a transfer --port-b transfer -o unordered
</code></pre>
<p>Notice that one can omit the destination chain parameter, as Hermes will automatically
figure it out by looking up the given connection on <code>ibc-0</code>.</p>
<pre><code class="language-json">🥳  ibc-0 =&gt; OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height { revision: 0, height: 129 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: None
        }
    )
)

🥳  ibc-1 =&gt; OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height { revision: 1, height: 126 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)

🥳  ibc-0 =&gt; OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height { revision: 0, height: 137 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)

🥳  ibc-1 =&gt; OpenConfirmChannel(
    OpenConfirm(
        Attributes {
            height: Height { revision: 1, height: 129 },
            port_id: PortId(&quot;transfer&quot;),
            channel_id: Some(ChannelId(&quot;channel-1&quot;)),
            connection_id: ConnectionId(&quot;connection-0&quot;),
            counterparty_port_id: PortId(&quot;transfer&quot;),
            counterparty_channel_id: Some(ChannelId(&quot;channel-1&quot;))
        }
    )
)

🥳  🥳  🥳  Channel handshake finished for Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0s,
}

Success: Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-0&quot;,
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    b_side: ChannelSide {
        chain: ProdChainHandle {
            chain_id: ChainId {
                id: &quot;ibc-1&quot;,
                version: 1,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: ConnectionId(
            &quot;connection-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
    },
    connection_delay: 0s,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaying"><a class="header" href="#relaying">Relaying</a></h1>
<p>This section describes the types of relaying that hermes can perform.</p>
<p>Hermes can send transactions triggered by IBC events. It currently handles channel handshake and packet events:</p>
<ul>
<li><a href="commands/relaying/./packets.html#packet-relaying">packets messages only</a></li>
<li><a href="commands/relaying/./handshakes.html">channel and packet messages</a></li>
</ul>
<h2 id="the-start-command"><a class="header" href="#the-start-command">The <code>start</code> Command</a></h2>
<p>The <code>start</code> command can be used to start hermes in IBC event listen mode.</p>
<pre><code class="language-shell">USAGE:
    hermes start &lt;OPTIONS&gt;

DESCRIPTION:
    Start the relayer in multi-chain mode. Relays packets and channel handshake messages between all chains in the config.
</code></pre>
<p>As described in next sub-sections, the type of relaying can be configured in the <code>global</code> section of the configuration file, by specifying different values in <code>strategy</code> field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-relaying"><a class="header" href="#packet-relaying">Packet Relaying</a></h1>
<p>This section describes the configuration and commands that can be used to start the relayer and relay packets
over one or multiple paths.</p>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="commands/relaying/packets.html#the-start-command">The <code>start</code> Command</a></li>
<li><a href="commands/relaying/packets.html#packet-streaming">Packet Streaming</a></li>
<li><a href="commands/relaying/packets.html#packet-delay">Packet Delay</a></li>
</ul>
<h2 id="the-start-command-1"><a class="header" href="#the-start-command-1">The <code>start</code> Command</a></h2>
<p>To relay packets only configure the <code>mode</code> section of the configuration file like so:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
# ...

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
# ...
</code></pre>
<p>Then start hermes using the start command:</p>
<pre><code class="language-shell">hermes start
</code></pre>
<p>The relayer sends packet transactions triggered by IBC packet events for all open channels between the configured chains.
This is also referred to packet streaming.</p>
<h2 id="packet-streaming"><a class="header" href="#packet-streaming">Packet Streaming</a></h2>
<p>After the relayer is started using the <code>start</code> command, it listens to IBC packet events emitted by any of
the configured chains. Assuming the events are coming from a <code>source</code> chain, the relayer builds packets
based on these events, packets that are then sent either to the <code>source</code> chain or the counterparty (<code>destination</code>) chain.</p>
<p>Current events and actions are:</p>
<ul>
<li><code>send_packet</code>: the relayer builds a packet message with the <code>packet</code> obtained from the event and any required proofs obtained from the counterparty of the chain where the message is sent. The concrete packet is:
<ul>
<li><code>MsgRecvPacket</code>, sent to <code>destination</code> chain if the channel is in open state on the <code>destination</code> chain, and a timeout has not occurred,</li>
<li><code>MsgTimeout</code>, sent to the <code>source</code> chain if the channel is in open state on the <code>destination</code> chain, but a timeout has occurred.</li>
<li><code>MsgTimeoutOnClose</code>, sent to the <code>source</code> chain if the channel is in closed state on the <code>destination</code> chain.</li>
</ul>
</li>
<li><code>write_acknowledgement</code>: the relayer builds a <code>MsgAcknowledgement</code> packet that is sent to the <code>destination</code> chain.</li>
</ul>
<p>In addition to these events, the relayer will also handle channel closing events:</p>
<ul>
<li><code>chan_close_init</code>: the relayer builds a <code>MsgChannelCloseConfirm</code> and sends it to the <code>destination</code> chain</li>
</ul>
<h2 id="packet-delay"><a class="header" href="#packet-delay">Packet Delay</a></h2>
<p>If the relay path is using a non-zero delay connection, then <code>hermes</code> will delay all packet transactions. The delay is relative to the submission time for the client update at the height required by the packet proof.
The delay is used to prevent light client attacks and ensures that misbehavior detection finalizes before the transaction is submitted.
For more information on the misbehavior detector see <a href="commands/relaying/../misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">the misbehaviour section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaying-of-handshake-messages"><a class="header" href="#relaying-of-handshake-messages">Relaying of Handshake Messages</a></h1>
<p>This section describes the configuration and commands that can be used to start the relayer and relay both handshake and packets
for connections and channels.</p>
<h2 id="the-start-command-2"><a class="header" href="#the-start-command-2">The <code>start</code> Command</a></h2>
<p>To relay packets and handshake messages configure the <code>mode</code> section of the configuration file like so:</p>
<pre><code class="language-toml">[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
# ...

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
# ...
</code></pre>
<p>Then start hermes using the start command:</p>
<pre><code class="language-shell">hermes start
</code></pre>
<p>The relayer sends handshake and packet transactions triggered by IBC events.</p>
<h2 id="completing-channel-handshakes"><a class="header" href="#completing-channel-handshakes">Completing Channel Handshakes</a></h2>
<p>After the relayer is started using the <code>start</code> command, it scans the chain state and will resume the handshake for any
channels or connections that are not in open state. It then listens to IBC events emitted by any of
the configured chains.</p>
<p>Assuming the events are coming from a <code>source</code> chain, the relayer determines the <code>destination</code> chain and builds the handshake messages based on these events. These are then sent to the <code>destination</code> chain.</p>
<p>In addition to the events described in <a href="commands/relaying/packets.html#packet-relaying">Packet Relaying</a>, the following IBC events may be handled:</p>
<ul>
<li>
<p>Channels (if <code>mode.channels.enabled=true</code>):</p>
<ul>
<li><code>chan_open_init</code>: the relayer builds a <code>MsgChannelOpenTry</code> message</li>
<li><code>chan_open_try</code>: the relayer builds a <code>MsgChannelOpenAck</code> message</li>
<li><code>chan_open_ack</code>: the relayer builds a <code>MsgChannelOpenConfirm</code> message</li>
<li><code>chan_open_confirm</code>: no message is sent out, channel opening is finished</li>
</ul>
</li>
<li>
<p>Connections (if <code>mode.connections.enabled=true</code>):</p>
<ul>
<li><code>conn_open_init</code>: the relayer builds a <code>MsgConnOpenTry</code> message</li>
<li><code>conn_open_try</code>: the relayer builds a <code>MsgConnOpenAck</code> message</li>
<li><code>conn_open_ack</code>: the relayer builds a <code>MsgConnOpenConfirm</code> message</li>
<li><code>conn_open_confirm</code>: no message is sent out, connection opening is finished</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relayer-listen-mode"><a class="header" href="#relayer-listen-mode">Relayer Listen Mode</a></h1>
<p>The relayer can be started in <code>listen</code> mode to display the events emitted by a given chain. <code>NewBlock</code> and <code>Tx</code> IBC events are shown.</p>
<pre><code class="language-shell">USAGE:
    hermes listen &lt;OPTIONS&gt;

DESCRIPTION:
    Listen to and display IBC events emitted by a chain

POSITIONAL ARGUMENTS:
    chain_id                  Identifier of the chain to listen for events from

FLAGS:
    -e, --event EVENT         Add an event type to listen for, can be repeated. Listen for all events by default (available: Tx, NewBlock)
</code></pre>
<p><strong>Example</strong></p>
<p>Start the relayer in listen mode for all <code>ibc-0</code> events and observe the output:</p>
<pre><code class="language-shell">hermes listen ibc-0
</code></pre>
<pre><code class="language-json">EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10914),
    events: [
        NewBlock(
            NewBlock {
                height: block::Height(10914),
            },
        ),
    ],
}
EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10915),
    events: [
        OpenInitConnection(
            OpenInit(
                Attributes {
                    height: block::Height(10915),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: None,
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],

...

EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10919),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10919),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10907,
                    },
                },
            ),
        ),
    ],
}

...

EventBatch {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    height: block::Height(10924),
    events: [
        UpdateClient(
            UpdateClient(
                Attributes {
                    height: block::Height(10924),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    client_type: Tendermint,
                    consensus_height: Height {
                        revision: 1,
                        height: 10912,
                    },
                },
            ),
        ),
        OpenAckConnection(
            OpenAck(
                Attributes {
                    height: block::Height(10924),
                    connection_id: Some(
                        ConnectionId(
                            &quot;connection-3&quot;,
                        ),
                    ),
                    client_id: ClientId(
                        &quot;07-tendermint-3&quot;,
                    ),
                    counterparty_connection_id: Some(
                        ConnectionId(
                            &quot;connection-5&quot;,
                        ),
                    ),
                    counterparty_client_id: ClientId(
                        &quot;07-tendermint-5&quot;,
                    ),
                },
            ),
        ),
    ],
}
</code></pre>
<h2 id="filter-events"><a class="header" href="#filter-events">Filter events</a></h2>
<p>The <code>listen</code> command accepts an <code>--event</code> flag to specify which event types to listen for.</p>
<p>At the moment, two event types are available:</p>
<ul>
<li><code>NewBlock</code> </li>
<li><code>Tx</code></li>
</ul>
<p>The <code>--event</code> flag can be repeated to specify more than one event type.</p>
<ul>
<li>To listen for only <code>NewBlock</code> events on <code>ibc-0</code>, invoke <code>hermes listen ibc-0 --event NewBlock</code></li>
<li>To listen for only <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen ibc-0 --event Tx</code></li>
<li>To listen for both <code>NewBlock</code> and <code>Tx</code> events on <code>ibc-0</code>, invoke <code>hermes listen ibc-0 --e NewBlock --event Tx</code></li>
</ul>
<p>If the <code>--event</code> flag is omitted, the relayer will subscribe to all event types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-upgrade"><a class="header" href="#client-upgrade">Client Upgrade</a></h1>
<h2 id="client-upgrade-command"><a class="header" href="#client-upgrade-command">Client Upgrade Command</a></h2>
<p>Use the <code>upgrade client</code> command to upgrade a client after a chain upgrade.</p>
<pre><code class="language-shell">USAGE:
    hermes upgrade client &lt;OPTIONS&gt;

DESCRIPTION:
    Upgrade an IBC client

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    dst_client_id             identifier of the client to be upgraded on destination chain
</code></pre>
<p><strong>Example</strong></p>
<p>Here is <a href="commands/upgrade/./test.html">an example</a> of a chain upgrade proposal submission and client upgrade.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-client-upgrade"><a class="header" href="#testing-client-upgrade">Testing Client Upgrade</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>gaiad <code>(v4.2.*)</code>, for example:</li>
</ul>
<pre><code class="language-shell">gaiad version --log_level error --long | head -n4
</code></pre>
<pre><code class="language-shell">name: gaia
server_name: gaiad
version: v4.2.0
commit: 535be14a8bdbfeb0d950914b5baa2dc72c6b081c
</code></pre>
<h2 id="testing-procedure"><a class="header" href="#testing-procedure">Testing procedure</a></h2>
<ol>
<li>
<p>Start two gaia instances and initialize hermes:</p>
<pre><code class="language-shell">./scripts/dev-env ~/.hermes/config.toml ibc-0 ibc-1
</code></pre>
<p>The <code>one-chain</code> script is invoked for each chain and modifies the <code>genesis.json</code> file to use a short window for governance proposals (<code>200s</code> for <code>max_deposit_period</code> and <code>voting_period</code>). Therefore, an upgrade proposal can be submitted, voted on and accepted within a short time.</p>
</li>
<li>
<p>Create one client on <code>ibc-1</code> for <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes create client ibc-1 ibc-0
</code></pre>
<pre><code class="language-json">Success: CreateClient(
   CreateClient(
       Attributes {
           height: Height { revision: 1, height: 9 },
           client_id: ClientId(
               &quot;07-tendermint-0&quot;,
           ),
           client_type: Tendermint,
           consensus_height: Height { revision: 0, height: 18 },
       },
   ),
)
</code></pre>
</li>
<li>
<p>Create and submit an upgrade plan for chain <code>ibc-0</code>:</p>
<p>Use the hermes test command to make an upgrade proposal. In the example below a software upgrade proposal is made for <code>ibc-0</code>, for the height <code>300</code> blocks from latest height. <code>10000000stake</code> is deposited.
The proposal includes the upgraded client state constructed from the state of <code>07-tendermint-0</code> client on <code>ibc-1</code> that was created in the previous step. In addition, the <code>unbonding_period</code> of the client is set to some new value (<code>400h</code>)</p>
<pre><code class="language-shell">hermes tx raw upgrade-chain ibc-0 ibc-1 07-tendermint-0 10000000 300
</code></pre>
<pre><code class="language-shell">Success: []
</code></pre>
<p>Note that the height offset should be picked such that the proposal plan height is reached after the <code>200s</code> voting period.</p>
</li>
<li>
<p>Verify that the proposal was accepted:</p>
<p>Query the upgrade plan to check that it was submitted correctly. Note the <code>height</code> at which the proposal will take effect (chain halts). Also <code>status: PROPOSAL_STATUS_VOTING_PERIOD</code>.</p>
<pre><code class="language-shell">gaiad query gov proposal 1 --home data/ibc-0/
</code></pre>
<pre><code class="language-text">content:
  '@type': /cosmos.upgrade.v1beta1.SoftwareUpgradeProposal
  description: upgrade the chain software and unbonding period
  plan:
    height: &quot;332&quot;
    info: upgrade the chain software and unbonding period
    name: test
    time: &quot;0001-01-01T00:00:00Z&quot;
    upgraded_client_state:
      '@type': /ibc.lightclients.tendermint.v1.ClientState
      allow_update_after_expiry: true
      allow_update_after_misbehaviour: true
      chain_id: ibc-0
      frozen_height:
        revision_height: &quot;0&quot;
        revision_number: &quot;0&quot;
      latest_height:
        revision_height: &quot;333&quot;
        revision_number: &quot;0&quot;
      max_clock_drift: 0s
      proof_specs:
      - inner_spec:
          child_order:
          - 0
          - 1
          child_size: 33
          empty_child: null
          hash: SHA256
          max_prefix_length: 12
          min_prefix_length: 4
        leaf_spec:
          hash: SHA256
          length: VAR_PROTO
          prefix: AA==
          prehash_key: NO_HASH
          prehash_value: SHA256
        max_depth: 0
        min_depth: 0
      - inner_spec:
          child_order:
          - 0
          - 1
          child_size: 32
          empty_child: null
          hash: SHA256
          max_prefix_length: 1
          min_prefix_length: 1
        leaf_spec:
          hash: SHA256
          length: VAR_PROTO
          prefix: AA==
          prehash_key: NO_HASH
          prehash_value: SHA256
        max_depth: 0
        min_depth: 0
      trust_level:
        denominator: &quot;0&quot;
        numerator: &quot;0&quot;
      trusting_period: 0s
      unbonding_period: 1440000s
      upgrade_path:
      - upgrade
      - upgradedIBCState
  title: upgrade_ibc_clients
deposit_end_time: &quot;2021-04-12T16:33:37.187389Z&quot;
final_tally_result:
  abstain: &quot;0&quot;
  &quot;no&quot;: &quot;0&quot;
  no_with_veto: &quot;0&quot;
  &quot;yes&quot;: &quot;0&quot;
proposal_id: &quot;1&quot;
status: PROPOSAL_STATUS_VOTING_PERIOD
submit_time: &quot;2021-04-12T16:30:17.187389Z&quot;
total_deposit:
- amount: &quot;10000000&quot;
  denom: stake
voting_end_time: &quot;2021-04-12T16:33:37.187389Z&quot;
voting_start_time: &quot;2021-04-12T16:30:17.187389Z&quot;
</code></pre>
</li>
<li>
<p>Vote on the proposal</p>
<p>The parameter <code>1</code> should match the <code>proposal_id:</code> from the upgrade proposal submitted at step 3.
This command must be issued while the proposal status is <code>PROPOSAL_STATUS_VOTING_PERIOD</code>. Confirm transaction when prompted.</p>
<pre><code class="language-shell">gaiad tx gov vote 1 yes --home data/ibc-0/data/ --keyring-backend test --keyring-dir data/ibc-0/ --chain-id ibc-0 --from validator
</code></pre>
<pre><code class="language-text">confirm transaction before signing and broadcasting [y/N]: y

{&quot;height&quot;:&quot;85&quot;,&quot;txhash&quot;:&quot;AC24D80B1BFE0832769DECFDD3B3DF999A363D5E4390B0B673344FFDED9150B2&quot;,&quot;codespace&quot;:&quot;&quot;,&quot;code&quot;:0,&quot;data&quot;:&quot;0A060A04766F7465&quot;,&quot;raw_log&quot;:&quot;[{\&quot;events\&quot;:[{\&quot;type\&quot;:\&quot;message\&quot;,\&quot;attributes\&quot;:[{\&quot;key\&quot;:\&quot;action\&quot;,\&quot;value\&quot;:\&quot;vote\&quot;},{\&quot;key\&quot;:\&quot;module\&quot;,\&quot;value\&quot;:\&quot;governance\&quot;},{\&quot;key\&quot;:\&quot;sender\&quot;,\&quot;value\&quot;:\&quot;cosmos1srfzw0jkyyn7wf0ps4zy0tuvdaclfj2ufgp6w3\&quot;}]},{\&quot;type\&quot;:\&quot;proposal_vote\&quot;,\&quot;attributes\&quot;:[{\&quot;key\&quot;:\&quot;option\&quot;,\&quot;value\&quot;:\&quot;VOTE_OPTION_YES\&quot;},{\&quot;key\&quot;:\&quot;proposal_id\&quot;,\&quot;value\&quot;:\&quot;1\&quot;}]}]}]&quot;,&quot;logs&quot;:[{&quot;msg_index&quot;:0,&quot;log&quot;:&quot;&quot;,&quot;events&quot;:[{&quot;type&quot;:&quot;message&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;action&quot;,&quot;value&quot;:&quot;vote&quot;},{&quot;key&quot;:&quot;module&quot;,&quot;value&quot;:&quot;governance&quot;},{&quot;key&quot;:&quot;sender&quot;,&quot;value&quot;:&quot;cosmos1srfzw0jkyyn7wf0ps4zy0tuvdaclfj2ufgp6w3&quot;}]},{&quot;type&quot;:&quot;proposal_vote&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;option&quot;,&quot;value&quot;:&quot;VOTE_OPTION_YES&quot;},{&quot;key&quot;:&quot;proposal_id&quot;,&quot;value&quot;:&quot;1&quot;}]}]}],&quot;info&quot;:&quot;&quot;,&quot;gas_wanted&quot;:&quot;200000&quot;,&quot;gas_used&quot;:&quot;43716&quot;,&quot;tx&quot;:null,&quot;timestamp&quot;:&quot;&quot;}
</code></pre>
</li>
<li>
<p>Wait approximately 200 seconds until the proposal changes status to <code>PROPOSAL_STATUS_PASSED</code>.
Note the <code>final tally_result</code> that includes the vote submitted in the previous step.</p>
<pre><code class="language-shell">gaiad query gov proposal 1 --home data/ibc-0/
</code></pre>
<pre><code class="language-text">   content:
     '@type': /cosmos.upgrade.v1beta1.SoftwareUpgradeProposal
     description: upgrade the chain software and unbonding period
   ...
   final_tally_result:
     abstain: &quot;0&quot;
     &quot;no&quot;: &quot;0&quot;
     no_with_veto: &quot;0&quot;
     &quot;yes&quot;: &quot;100000000000&quot;
   proposal_id: &quot;1&quot;
   status: PROPOSAL_STATUS_PASSED
   submit_time: &quot;2021-04-12T16:30:17.187389Z&quot;
   total_deposit:
   - amount: &quot;10000000&quot;
     denom: stake
   voting_end_time: &quot;2021-04-12T16:33:37.187389Z&quot;
   voting_start_time: &quot;2021-04-12T16:30:17.187389Z&quot;
</code></pre>
</li>
<li>
<p>Test the <code>upgrade client</code> CLI</p>
<p>The following command performs the upgrade for client <code>07-tendermint-0</code>. It outputs two events, one for the updated client state,
and another for the upgraded state.</p>
<pre><code class="language-shell">hermes upgrade client ibc-1 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height { revision: 1, height: 438 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 0, height: 440 },
            },
            header: Some(
                Tendermint(..)
            ),
        },
    ),
    UpgradeClient(
        UpgradeClient(
            Attributes {
                height: Height { revision: 1, height: 438 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 0, height: 441 },
            },
        ),
    ),
]
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misbehaviour"><a class="header" href="#misbehaviour">Misbehaviour</a></h1>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="commands/misbehaviour/index.html#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></li>
</ul>
<h2 id="monitoring-misbehaviour-and-evidence-submission"><a class="header" href="#monitoring-misbehaviour-and-evidence-submission">Monitoring Misbehaviour and Evidence Submission</a></h2>
<p>Use the <code>mishbehaviour</code> command to monitor the updates for a given client, detect certain types of misbehaviour and
submit evidence to the chain. If the evidence passes the on-chain validation, the client is frozen. Further packets
cannot be relayed using the frozen client.</p>
<pre><code class="language-shell">USAGE:
    hermes misbehaviour &lt;OPTIONS&gt;

DESCRIPTION:
    Listen to client update IBC events and handles misbehaviour

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain where client updates are monitored for misbehaviour
    client_id                 identifier of the client to be monitored for misbehaviour
</code></pre>
<p>The misbehaviour monitor starts by analyzing all headers used in prior client updates.
Once finished it registers for update client events and checks any new headers for misbehaviour.
If it detects evidence of misbehaviour, it submits a transaction with the evidence to the chain.
If the chain validates the transaction then the monitor exits.</p>
<blockquote>
<p>This is an experimental feature.</p>
</blockquote>
<p>The following types of misbehaviour are handled:</p>
<ol>
<li>
<p><strong>Fork</strong></p>
<p>Assumes at least one consensus state before the fork point exists.
Let existing consensus states on chain B be: <code>[Sn,.., Sf, Sf-1, S0]</code> with <code>Sf-1</code> being
the most recent state before the fork.
Chain A is queried for a header <code>Hf'</code> at <code>Sf.height</code> and if it is different than the <code>Hf</code>
in the event for the client update (the one that has generated <code>Sf</code> on chain), then the two
headers are included in the evidence and submitted.
Note that in this case the headers are different but have the same height.</p>
</li>
<li>
<p><strong>BFT time violation for an unavailable header</strong></p>
<p>Some header with a height that is higher than the latest
height on chain <code>A</code> has been accepted and a consensus state was created on <code>B</code>. Note that this implies
that the timestamp of this header must be within the <code>clock_drift</code> of the client.
Assume the client on <code>B</code> has been updated with <code>h2</code>(not present on/ produced by chain <code>A</code>)
and it has a timestamp of <code>t2</code> that is at most <code>clock_drift</code> in the future.
Then the latest header from <code>A</code> is fetched, let it be <code>h1</code>, with a timestamp of <code>t1</code>.
If <code>t1 &gt;= t2</code> then evidence of misbehavior is submitted to A.</p>
</li>
</ol>
<p><strong>Example</strong></p>
<p>The <code>hermes misbehaviour</code> outputs an error message displaying <code>MISBEHAVIOUR DETECTED</code>:</p>
<pre><code class="language-shell">hermes misbehaviour ibc-0 07-tendermint-0
</code></pre>
<pre><code class="language-json">Apr 13 20:04:03.347  INFO ibc_relayer::foreign_client: checking misbehaviour for consensus state heights [Height { revision: 1, height: 195 }, Height { revision: 1, height: 85 }, Height { revision: 1, height: 28 }]
Apr 13 20:04:04.425 ERROR ibc_relayer::foreign_client: MISBEHAVIOUR DETECTED ClientId(&quot;07-tendermint-0&quot;) h1: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 } h2: Height { revision: 1, height: 195 }-Height { revision: 1, height: 85 }, sending evidence
Apr 13 20:04:05.070  INFO ibc_relayer_cli::commands::misbehaviour: evidence submission result [ClientMisbehaviour(ClientMisbehaviour(Attributes { height: Height { revision: 0, height: 1521 }, client_id: ClientId(&quot;07-tendermint-0&quot;), client_type: Tendermint, consensus_height: Height { revision: 1, height: 195 } }))]

Success: Some(
    ClientMisbehaviour(
        ClientMisbehaviour(
            Attributes {
                height: Height {
                    revision: 0,
                    height: 1521,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 195,
                },
            },
        ),
    ),
)
</code></pre>
<p>Querying client state from this point will show the client is in frozen state, with <code>frozen_height</code> indicating the height at which the client was frozen:</p>
<pre><code class="language-shell">hermes query client state ibc-0 07-tendermint-0 | jq
</code></pre>
<pre><code class="language-json">{
  &quot;result&quot;: {
    &quot;allow_update_after_expiry&quot;: true,
    &quot;allow_update_after_misbehaviour&quot;: true,
    &quot;chain_id&quot;: &quot;ibc-1&quot;,
    &quot;frozen_height&quot;: {
      &quot;revision_height&quot;: 16,
      &quot;revision_number&quot;: 1
    },
    &quot;latest_height&quot;: {
      &quot;revision_height&quot;: 16,
      &quot;revision_number&quot;: 1
    },
    &quot;max_clock_drift&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 3
    },
    &quot;trust_level&quot;: {
      &quot;denominator&quot;: &quot;3&quot;,
      &quot;numerator&quot;: &quot;1&quot;
    },
    &quot;trusting_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1209600
    },
    &quot;unbonding_period&quot;: {
      &quot;nanos&quot;: 0,
      &quot;secs&quot;: 1814400
    },
    &quot;upgrade_path&quot;: [
      &quot;upgrade&quot;,
      &quot;upgradedIBCState&quot;
    ]
  },
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Hermes supports querying for different objects that exist on a configured chain.</p>
<p>The <code>query</code> command provides the following sub-commands:</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client</code></td><td><a href="commands/queries/./client.html">Query information about clients</a></td></tr>
<tr><td><code>clients</code></td><td><a href="commands/queries/./client.html">Query all clients</a></td></tr>
<tr><td><code>connection</code></td><td><a href="commands/queries/./connection.html">Query information about connections</a></td></tr>
<tr><td><code>connections</code></td><td><a href="commands/queries/./connection.html">Query the identifiers of all connections on a chain</a></td></tr>
<tr><td><code>channel</code></td><td><a href="commands/queries/./channel.html">Query information about channels</a></td></tr>
<tr><td><code>channels</code></td><td><a href="commands/queries/./channel.html">Query the identifiers of all channels on a given chain</a></td></tr>
<tr><td><code>packet</code></td><td><a href="commands/queries/./packet.html">Query information about packets</a></td></tr>
<tr><td><code>tx</code></td><td><a href="commands/queries/./tx.html">Query information about transactions</a></td></tr>
</tbody></table>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code>USAGE:
    hermes query &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query objects from the chain

SUBCOMMANDS:
    client         Query information about clients
    clients        Query clients
    connection     Query information about connections
    connections    Query the identifiers of all connections on a chain
    channel        Query information about channels
    channels       Query the identifiers of all channels on a given chain
    packet         Query information about packets
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/client.html#query-clients">Query Clients</a></li>
<li><a href="commands/queries/client.html#query-client-data">Query Client Data</a>
<ul>
<li><a href="commands/queries/client.html#query-the-client-state">Query the client state</a></li>
<li><a href="commands/queries/client.html#query-the-client-consensus-state">Query the client consensus state</a></li>
<li><a href="commands/queries/client.html#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></li>
<li><a href="commands/queries/client.html#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></li>
</ul>
</li>
</ul>
<h1 id="query-clients"><a class="header" href="#query-clients">Query Clients</a></h1>
<p>Use the <code>query clients</code> command to query the identifiers of all clients on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query clients &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all clients on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query

FLAGS:
    -s, --src-chain-id ID     filter for clients which target a specific chain id (implies '-o')
    -o, --omit-chain-ids      omit printing the source chain for each client (default: false)
</code></pre>
<p><strong>Example</strong></p>
<p>Query all clients on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query clients ibc-1
</code></pre>
<pre><code class="language-json">Success: [
    ClientChain {
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        chain_id: ChainId {
            id: &quot;ibc-0&quot;,
            version: 0,
        },
    },
    ClientChain {
        client_id: ClientId(
            &quot;07-tendermint-1&quot;,
        ),
        chain_id: ChainId {
            id: &quot;ibc-2&quot;,
            version: 2,
        },
    },
]
</code></pre>
<p>Query all clients on <code>ibc-1</code> having <code>ibc-2</code> as their source chain:</p>
<pre><code class="language-shell">hermes query clients ibc-1 -s ibc-2
</code></pre>
<pre><code class="language-json">Success: [
    ClientId(
        &quot;07-tendermint-1&quot;,
    ),
]
</code></pre>
<h1 id="query-client-data"><a class="header" href="#query-client-data">Query Client Data</a></h1>
<p>Use the <code>query client</code> command to query the information about a specific client.</p>
<pre><code class="language-shell">USAGE:
    hermes query client &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about clients

SUBCOMMANDS:
    state      query client full state
    consensus  query client consensus
    connections query client connections
</code></pre>
<h2 id="query-the-client-state"><a class="header" href="#query-the-client-state">Query the client state</a></h2>
<p>Use the <code>query client state</code> command to query the client state of a client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client state &lt;OPTIONS&gt;

DESCRIPTION:
    Query client full state

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -H, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the state of client <code>07-tendermint-2</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query client state ibc-1 07-tendermint-1
</code></pre>
<pre><code class="language-json">Success: ClientState {
    chain_id: ChainId {
        id: &quot;ibc-2&quot;,
        version: 2,
    },
    trust_level: TrustThresholdFraction {
        numerator: 1,
        denominator: 3,
    },
    trusting_period: 1209600s,
    unbonding_period: 1814400s,
    max_clock_drift: 3s,
    frozen_height: Height {
        revision: 0,
        height: 0,
    },
    latest_height: Height {
        revision: 2,
        height: 3069,
    },
    upgrade_path: [
        &quot;upgrade&quot;,
        &quot;upgradedIBCState&quot;,
    ],
    allow_update_after_expiry: true,
    allow_update_after_misbehaviour: true,
}
</code></pre>
<h2 id="query-the-client-consensus-state"><a class="header" href="#query-the-client-consensus-state">Query the client consensus state</a></h2>
<p>Use the <code>query client consensus</code> command to query the consensus states of a given client, or the state at a specified height:</p>
<pre><code class="language-shell">USAGE:
    hermes query client consensus &lt;OPTIONS&gt;

DESCRIPTION:
    Query client consensus state

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -c, --consensus-height    CONSENSUS-HEIGHT
    -s, --heights-only        show only consensus heights
    -H, --height HEIGHT       the chain height context to be used, applicable only to a specific height
</code></pre>
<p><strong>Example</strong></p>
<p>Query the states of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client consensus ibc-0 07-tendermint-0 --heights-only
</code></pre>
<pre><code class="language-json">Success: [
    Height {
        revision: 1,
        height: 3049,
    },
    Height {
        revision: 1,
        height: 2888,
    },
    Height {
        revision: 1,
        height: 2736,
    },
    Height {
        revision: 1,
        height: 2729,
    },
    Height {
        revision: 1,
        height: 2724,
    },
    Height {
        revision: 1,
        height: 2717,
    },
]
</code></pre>
<p>Query <code>ibc-0</code> at height <code>2800</code> for the consensus state for height <code>2724</code>:</p>
<pre><code class="language-shell">hermes query client consensus ibc-0 07-tendermint-0 -c 2724 -h 2800
</code></pre>
<pre><code class="language-json">Success: ConsensusState {
    timestamp: Time(
        2021-04-13T14:11:20.969154Z
    ),
    root: CommitmentRoot(
        &quot;371DD19003221B60162D42C78FD86ABF95A572F3D9497084584B75F97B05B70C&quot;
    ),
    next_validators_hash: Hash::Sha256(
        740950668B6705A136D041914FC219045B1D0AD1C6A284C626BF5116005A98A7
    ),
}
</code></pre>
<h2 id="query-the-identifiers-of-all-connections-associated-with-a-given-client"><a class="header" href="#query-the-identifiers-of-all-connections-associated-with-a-given-client">Query the identifiers of all connections associated with a given client</a></h2>
<p>Use the <code>query client connections</code> command to query the connections associated with a given client:</p>
<pre><code class="language-shell">USAGE:
    hermes query client connections &lt;OPTIONS&gt;

DESCRIPTION:
    Query client connections

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query

FLAGS:
    -H, --height HEIGHT       the chain height which this query should reflect
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connections of client <code>07-tendermint-0</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client connections ibc-0 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: [
    ConnectionId(&quot;connection-0&quot;),
    ConnectionId(&quot;connection-1&quot;),
]
</code></pre>
<h2 id="query-for-the-header-used-in-a-client-update-at-a-certain-height"><a class="header" href="#query-for-the-header-used-in-a-client-update-at-a-certain-height">Query for the header used in a client update at a certain height</a></h2>
<pre><code>USAGE:
    hermes query client header &lt;OPTIONS&gt;

DESCRIPTION:
    Query for the header used in a client update at a certain height

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    client_id                 identifier of the client to query
    consensus_height          height of header to query

FLAGS:
    -H, --height HEIGHT       the chain height context for the query
</code></pre>
<p><strong>Example</strong></p>
<p>Query for the header used in the <code>07-tendermint-0</code> client update at height 2724 on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query client header ibc-0 07-tendermint-0 2724
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 0,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 2724,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/connection.html#query-connections">Query Connections</a></li>
<li><a href="commands/queries/connection.html#query-connection-data">Query Connection Data</a>
<ul>
<li><a href="commands/queries/connection.html#query-the-connection-end-data">Query the connection end data</a></li>
<li><a href="commands/queries/connection.html#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></li>
</ul>
</li>
</ul>
<h1 id="query-connections"><a class="header" href="#query-connections">Query Connections</a></h1>
<p>Use the <code>query connections</code> command to query the identifiers of all connections on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query connections &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all connections on a chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all connections on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connections ibc-1
</code></pre>
<pre><code class="language-json">Success: [
    ConnectionId(
        &quot;connection-0&quot;,
    ),
    ConnectionId(
        &quot;connection-1&quot;,
    ),
]
</code></pre>
<h1 id="query-connection-data"><a class="header" href="#query-connection-data">Query Connection Data</a></h1>
<p>Use the <code>query connection</code> commands to query a specific connection.</p>
<pre><code class="language-shell">USAGE:
    hermes query connection &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about connection(s)

SUBCOMMANDS:
    end        query connection end
    channels   query connection channels
</code></pre>
<h2 id="query-the-connection-end-data"><a class="header" href="#query-the-connection-end-data">Query the connection end data</a></h2>
<p>Use the <code>query connection end</code> command to query the connection end:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection end &lt;OPTIONS&gt;

DESCRIPTION:
    query connection end

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    connection_id             identifier of the connection to query

FLAGS:
    -H, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the connection end of connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection end ibc-1 connection-1
</code></pre>
<pre><code class="language-json">Success: ConnectionEnd {
    state: Open,
    client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    counterparty: Counterparty {
        client_id: ClientId(
            &quot;07-tendermint-0&quot;,
        ),
        connection_id: Some(
            ConnectionId(
                &quot;connection-0&quot;,
            ),
        ),
        prefix: ibc,
    },
    versions: [
        Version {
            identifier: &quot;1&quot;,
            features: [
                &quot;ORDER_ORDERED&quot;,
                &quot;ORDER_UNORDERED&quot;,
            ],
        },
    ],
    delay_period: 0s,
}
</code></pre>
<h2 id="query-the-identifiers-of-all-channels-associated-with-a-given-connection"><a class="header" href="#query-the-identifiers-of-all-channels-associated-with-a-given-connection">Query the identifiers of all channels associated with a given connection</a></h2>
<p>Use the <code>query connection channels</code> command to query the identifiers of the channels associated with a given connection:</p>
<pre><code class="language-shell">USAGE:
    hermes query connection channels &lt;OPTIONS&gt;

DESCRIPTION:
    query connection channels

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    connection_id             identifier of the connection to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channels associated with connection <code>connection-1</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query connection channels ibc-1 connection-1
</code></pre>
<pre><code class="language-json">Success: [
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents-9"><a class="header" href="#table-of-contents-9">Table of Contents</a></h1>
<ul>
<li><a href="commands/queries/channel.html#query-channels">Query Channels</a></li>
<li><a href="commands/queries/channel.html#query-channel-data">Query Channel Data</a>
<ul>
<li><a href="commands/queries/channel.html#query-the-channel-end-data">Query the channel end data</a></li>
<li><a href="commands/queries/channel.html#query-the-channel-data-for-both-ends-of-a-channel">Query the channel data for both ends of a channel</a></li>
</ul>
</li>
</ul>
<h1 id="query-channels"><a class="header" href="#query-channels">Query Channels</a></h1>
<p>Use the <code>query channels</code> command to query the identifiers of all channels on a given chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query channels &lt;OPTIONS&gt;

DESCRIPTION:
    Query the identifiers of all channels on a given chain

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query all channels on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channels ibc-1
</code></pre>
<pre><code class="language-json">Success: [
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-0&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
    PortChannelId {
        channel_id: ChannelId(
            &quot;channel-1&quot;,
        ),
        port_id: PortId(
            &quot;transfer&quot;,
        ),
    },
]
</code></pre>
<h1 id="query-channel-data"><a class="header" href="#query-channel-data">Query Channel Data</a></h1>
<p>Use the <code>query channel</code> commands to query the information about a specific channel.</p>
<pre><code class="language-shell">USAGE:
    hermes query channel &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about channels

SUBCOMMANDS:
    end        Query channel end
    ends       Query channel ends and underlying connection and client objects
</code></pre>
<h2 id="query-the-channel-end-data"><a class="header" href="#query-the-channel-end-data">Query the channel end data</a></h2>
<p>Use the <code>query channel end</code> command to query the channel end:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel end &lt;OPTIONS&gt;

DESCRIPTION:
    Query channel end

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query

FLAGS:
    -H, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes query channel end ibc-1 transfer channel-1
</code></pre>
<pre><code class="language-json">Success: ChannelEnd {
    state: Open,
    ordering: Unordered,
    remote: Counterparty {
        port_id: PortId(
            &quot;transfer&quot;,
        ),
        channel_id: Some(
            ChannelId(
                &quot;channel-0&quot;,
            ),
        ),
    },
    connection_hops: [
        ConnectionId(
            &quot;connection-1&quot;,
        ),
    ],
    version: &quot;ics20-1&quot;,
}
</code></pre>
<h2 id="query-the-channel-data-for-both-ends-of-a-channel"><a class="header" href="#query-the-channel-data-for-both-ends-of-a-channel">Query the channel data for both ends of a channel</a></h2>
<p>Use the <code>query channel ends</code> command to obtain both ends of a channel:</p>
<pre><code class="language-shell">USAGE:
    hermes query channel ends &lt;OPTIONS&gt;

DESCRIPTION:
    Query channel ends and underlying connection and client objects

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query

FLAGS:
    -H, --height HEIGHT       height of the state to query
    -v, --verbose             enable verbose output, displaying all details of channels, connections &amp; clients
</code></pre>
<p><strong>Example</strong></p>
<p>Query the channel end of channel <code>channel-1</code> on port <code>transfer</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query channel ends ibc-0 transfer channel-1
</code></pre>
<pre><code class="language-json">Success: ChannelEndsSummary {
    chain_id: ChainId {
        id: &quot;ibc-0&quot;,
        version: 0,
    },
    client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    connection_id: ConnectionId(
        &quot;connection-1&quot;,
    ),
    channel_id: ChannelId(
        &quot;channel-1&quot;,
    ),
    port_id: PortId(
        &quot;transfer&quot;,
    ),
    counterparty_chain_id: ChainId {
        id: &quot;ibc-2&quot;,
        version: 2,
    },
    counterparty_client_id: ClientId(
        &quot;07-tendermint-1&quot;,
    ),
    counterparty_connection_id: ConnectionId(
        &quot;connection-1&quot;,
    ),
    counterparty_channel_id: ChannelId(
        &quot;channel-1&quot;,
    ),
    counterparty_port_id: PortId(
        &quot;transfer&quot;,
    ),
}
</code></pre>
<p>Passing the <code>-v</code> flag will additionally print all the details of the
channel, connection, and client on both ends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-queries"><a class="header" href="#packet-queries">Packet Queries</a></h1>
<p>Use the <code>query packet</code> commands to query information about packets.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about packets

SUBCOMMANDS:
    commitments          Query packet commitments
    commitment           Query packet commitment
    acks                 Query packet acknowledgments
    ack                  Query packet acknowledgment
    unreceived-packets   Query unreceived packets
    unreceived-acks      Query unreceived acknowledgments
</code></pre>
<h2 id="table-of-contents-10"><a class="header" href="#table-of-contents-10">Table of Contents</a></h2>
<ul>
<li><a href="commands/queries/packet.html#packet-commitments">Packet Commitments</a></li>
<li><a href="commands/queries/packet.html#packet-commitment-with-sequence">Packet Commitment with Sequence</a></li>
<li><a href="commands/queries/packet.html#packet-acknowledgments">Packet Acknowledgments</a></li>
<li><a href="commands/queries/packet.html#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></li>
<li><a href="commands/queries/packet.html#unreceived-packets">Unreceived Packets</a></li>
<li><a href="commands/queries/packet.html#unreceived-acknowledgments">Unreceived Acknowledgments</a></li>
</ul>
<h2 id="packet-commitments"><a class="header" href="#packet-commitments">Packet Commitments</a></h2>
<p>Use the <code>query packet commitments</code> command to query the sequence numbers of all packets that have been sent but not yet acknowledged (these are the packets that still have their commitments stored).</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitments &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet commitments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the sequence numbers of packets that still have commitments on <code>ibc-0</code> and that were sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitments ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-json">Success: PacketSeqs {
    height: Height {
        revision: 0,
        height: 9154,
    },
    seqs: [
        1,
        2,
        3
    ],
}
</code></pre>
<h2 id="packet-commitment-with-sequence"><a class="header" href="#packet-commitment-with-sequence">Packet Commitment with Sequence</a></h2>
<p>Use the <code>query packet commitment</code> command to query the commitment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet commitment &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet commitment

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
    sequence                  sequence of packet to query

FLAGS:
    -H, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-0</code> for the commitment of packet with sequence <code>3</code> sent on <code>transfer</code> port and <code>channel-0</code>:</p>
<pre><code class="language-shell">hermes query packet commitment ibc-0 transfer channel-0 3
</code></pre>
<pre><code class="language-json">Success: &quot;F9458DC7EBEBCD6D18E983FCAB5BD752CC2A74532BBD50B812DB229997739EFC&quot;
</code></pre>
<h2 id="packet-acknowledgments"><a class="header" href="#packet-acknowledgments">Packet Acknowledgments</a></h2>
<p>Use the <code>query packet acknowledgments</code> command to query the sequence numbers of all packets that have been acknowledged.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet acks &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet acknowledgments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the sequence numbers of packets acknowledged that were received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet acks ibc-1 transfer channel-1
</code></pre>
<pre><code class="language-json">Success: PacketSeqs {
    height: Height {
        revision: 1,
        height: 9547,
    },
    seqs: [
        1,
        2,
        3
    ],
}
</code></pre>
<h2 id="packet-acknowledgment-with-sequence"><a class="header" href="#packet-acknowledgment-with-sequence">Packet Acknowledgment with Sequence</a></h2>
<p>Use the <code>query packet acknowledgment</code> command to query the acknowledgment value of a packet with a given sequence number.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet ack &lt;OPTIONS&gt;

DESCRIPTION:
    Query packet acknowledgment

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    port_id                   identifier of the port to query
    channel_id                identifier of the channel to query
    sequence                  sequence of packet to query

FLAGS:
    -H, --height HEIGHT       height of the state to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>ibc-1</code> for the acknowledgment of packet with sequence <code>2</code> received on <code>transfer</code> port and <code>channel-1</code>:</p>
<pre><code class="language-shell">hermes query packet ack ibc-1 transfer channel-1 2
</code></pre>
<pre><code class="language-json">Success: &quot;08F7557ED51826FE18D84512BF24EC75001EDBAF2123A477DF72A0A9F3640A7C&quot;
</code></pre>
<h2 id="unreceived-packets"><a class="header" href="#unreceived-packets">Unreceived Packets</a></h2>
<p>Use the <code>query packet unreceived-packets</code> command to query the sequence numbers of all packets that have been sent on the source chain but not yet received on the destination chain.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet unreceived-packets &lt;OPTIONS&gt;

DESCRIPTION:
    Query unreceived packets

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain for the unreceived sequences
    port_id                   port identifier
    channel_id                channel identifier
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>transfer</code> port and <code>channel-1</code> on <code>ibc-1</code> for the sequence numbers of packets sent on <code>ibc-0</code> but not yet received:</p>
<pre><code class="language-shell">hermes query packet unreceived-packets ibc-1 transfer channel-1
</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<h2 id="unreceived-acknowledgments"><a class="header" href="#unreceived-acknowledgments">Unreceived Acknowledgments</a></h2>
<p>Use the <code>query packet unreceived-acks</code> command to query the sequence numbers of all packets that have not yet been acknowledged.</p>
<pre><code class="language-shell">USAGE:
    hermes query packet unreceived-acks &lt;OPTIONS&gt;

DESCRIPTION:
    Query unreceived acknowledgments

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query the unreceived acknowledgments
    port_id                   port identifier
    channel_id                channel identifier
</code></pre>
<p><strong>Example</strong></p>
<p>Query <code>transfer</code> port and <code>channel-0</code> on <code>ibc-0</code> for the sequence numbers of packets received by <code>ibc-1</code> but not yet acknowledged on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes query packet unreceived-acks ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-json">Success: [
    1,
    2,
    3
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tx-queries"><a class="header" href="#tx-queries">Tx Queries</a></h1>
<p>Use the <code>query tx</code> command to query information about transaction(s).</p>
<pre><code class="language-shell">USAGE:
    hermes query tx &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Query information about transactions

SUBCOMMANDS:
    events     Query the events emitted by transaction
</code></pre>
<h2 id="table-of-contents-11"><a class="header" href="#table-of-contents-11">Table of Contents</a></h2>
<ul>
<li><a href="commands/queries/tx.html#transaction-events">Transaction Events</a></li>
</ul>
<h2 id="transaction-events"><a class="header" href="#transaction-events">Transaction Events</a></h2>
<p>Use the <code>query tx events</code> command to obtain a list of events that a chain generated as a consequence of
delivering a transaction.</p>
<pre><code class="language-shell">USAGE:
    hermes query tx events &lt;OPTIONS&gt;

DESCRIPTION:
    Query the events emitted by transaction

POSITIONAL ARGUMENTS:
    chain_id                  identifier of the chain to query
    hash                      transaction hash to query
</code></pre>
<p><strong>Example</strong></p>
<p>Query chain <code>ibc-0</code> for the events emitted due to transaction with hash
<code>6EDBBCBCB779F9FC9D6884ACDC4350E69720C4B362E4ACE6C576DE792F837490</code>:</p>
<pre><code class="language-shell">hermes query tx events ibc-0 6EDBBCBCB779F9FC9D6884ACDC4350E69720C4B362E4ACE6C576DE792F837490
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 4,
                height: 6628239,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-139&quot;) Sequence(2),
        },
    ),
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-transactions"><a class="header" href="#raw-transactions">Raw Transactions</a></h1>
<p>There are a number of simple commands that perform minimal validation, build and send IBC transactions.</p>
<p>The <code>tx raw</code> command provides the following sub-commands:</p>
<table><thead><tr><th>CLI name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>create-client</code></td><td><a href="commands/raw/./client.html#create-client">Create a client for source chain on destination chain</a></td></tr>
<tr><td><code>update-client</code></td><td><a href="commands/raw/./client.html#update-client">Update the specified client on destination chain</a></td></tr>
<tr><td><code>conn-init</code></td><td><a href="commands/raw/./connection.html#connection-init">Initialize a connection (ConnectionOpenInit)</a></td></tr>
<tr><td><code>conn-try</code></td><td><a href="commands/raw/./connection.html#connection-try">Relay the connection attempt (ConnectionOpenTry)</a></td></tr>
<tr><td><code>conn-ack</code></td><td><a href="commands/raw/./connection.html#connection-ack">Relay acknowledgment of a connection attempt (ConnectionOpenAck)</a></td></tr>
<tr><td><code>conn-confirm</code></td><td><a href="commands/raw/./connection.html#connection-confirm">Confirm opening of a connection (ConnectionOpenConfirm)</a></td></tr>
<tr><td><code>chan-open-init</code></td><td><a href="commands/raw/./channel-open.html#channel-open-init">Initialize a channel (ChannelOpenInit)</a></td></tr>
<tr><td><code>chan-open-try</code></td><td><a href="commands/raw/./channel-open.html#channel-open-try">Relay the channel attempt (ChannelOpenTry)</a></td></tr>
<tr><td><code>chan-open-ack</code></td><td><a href="commands/raw/./channel-open.html#channel-open-ack">Relay acknowledgment of a channel attempt (ChannelOpenAck)</a></td></tr>
<tr><td><code>chan-open-close</code></td><td><a href="commands/raw/./channel-open.html#channel-open-close">Confirm opening of a channel (ChannelOpenConfirm)</a></td></tr>
<tr><td><code>chan-close-init</code></td><td><a href="commands/raw/./channel-close.html#channel-close-init">Initiate the closing of a channel (ChannelCloseInit)</a></td></tr>
<tr><td><code>chan-close-confirm</code></td><td><a href="commands/raw/./channel-close.html#channel-close-confirm">Confirm the closing of a channel (ChannelCloseConfirm)</a></td></tr>
<tr><td><code>ft-transfer</code></td><td><a href="commands/raw/./packet.html#fungible-token-transfer">Send a fungible token transfer test transaction (ICS20 MsgTransfer</a></td></tr>
<tr><td><code>packet-recv</code></td><td><a href="commands/raw/./packet.html#relay-receive-and-timeout-packets">Relay receive or timeout packets</a></td></tr>
<tr><td><code>packet-ack</code></td><td><a href="commands/raw/./packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></td></tr>
</tbody></table>
<p>The main purpose of these commands is to support development and testing, and continuous integration. These CLIs take quite a few parameters and they are explained in the individual sub-sections.</p>
<p>At a high level, most commands follow this template:</p>
<pre><code class="language-shell">hermes tx raw &lt;ibc-datagram&gt; &lt;dst-chain-id&gt; &lt;src-chain-id&gt; [-d &lt;dst-obj-id&gt; -s &lt;src-obj-id&gt;]*
</code></pre>
<p>In the command template above:</p>
<ul>
<li>
<p><code>ibc-datagram</code> - identifies the &quot;main&quot; IBC message that is being sent, e.g. <code>conn-init</code>, <code>conn-try</code>, <code>chan-open-init</code>, etc. To ensure successful processing on the receiving chain, the majority of these commands build and send two messages: one <code>UpdateClient</code> message followed by the actual IBC message. These two messages are included in a single transaction. This is done for all IBC datagrams that include proofs collected from the source chain.</p>
<p>The messages that do not require proofs are:</p>
<ul>
<li><code>MsgCreateClient</code> (<code>create-client</code> command),</li>
<li><code>MsgConnectionOpenInit</code> (<code>conn-open-init</code> command),</li>
<li><code>MsgChannelOpenInit</code> (<code>chan-open-init</code> command),</li>
<li><code>MsgChannelCloseInit</code> (<code>chan-close-init</code> command) and</li>
<li><code>MsgTransfer</code> (<code>ft-transfer</code> command)</li>
</ul>
</li>
<li>
<p><code>dst-chain-id</code> - is the identifier of the chain where the transaction will be sent.</p>
</li>
<li>
<p><code>src-chain-id</code> - is the identifier of the chain that is queried for the data that is included in the transaction, e.g. connection data, client proofs, etc. To ensure correct on-chain state, the relayer also queries the destination chain, however it does not include this information in the Tx to the destination chain.</p>
</li>
<li>
<p><code>dst-obj-id</code> - the identifier of an object on destination chain required by the datagram, e.g. the <code>client-id</code> associated with the connection on destination chain in connection datagrams. Or the <code>connection-id</code> in a <code>ConnOpenAck</code> datagram.</p>
</li>
<li>
<p><code>src-obj-id</code> - the identifier of an object on the source chain, required by the datagram, e.d. the <code>client-id</code> of the connection on source chain.</p>
</li>
<li>
<p>More details about the <code>tx raw</code> commands can be found in the following sections:</p>
<ul>
<li><a href="commands/raw/./client.html">Client</a></li>
<li><a href="commands/raw/./connection.html">Connection</a></li>
<li><a href="commands/raw/./channel-open.html">Channel Open</a></li>
<li><a href="commands/raw/./channel-close.html">Channel Close</a></li>
<li><a href="commands/raw/./packet.html">Packet</a></li>
</ul>
</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-shell">USAGE:
    hermes tx raw &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Raw commands for sending transactions to a configured chain.

SUBCOMMANDS:
    help                Get usage information
    create-client       Create a client for source chain on destination chain
    update-client       Update the specified client on destination chain
    conn-init           Initialize a connection (ConnectionOpenInit)
    conn-try            Relay the connection attempt (ConnectionOpenTry)
    conn-ack            Relay acknowledgment of a connection attempt (ConnectionOpenAck)
    conn-confirm        Confirm opening of a connection (ConnectionOpenConfirm)
    chan-open-init      Initialize a channel (ChannelOpenInit)
    chan-open-try       Relay the channel attempt (ChannelOpenTry)
    chan-open-ack       Relay acknowledgment of a channel attempt (ChannelOpenAck)
    chan-open-confirm   Confirm opening of a channel (ChannelOpenConfirm)
    chan-close-init     Initiate the closing of a channel (ChannelCloseInit)
    chan-close-confirm  Confirm the closing of a channel (ChannelCloseConfirm)
    ft-transfer         Send a fungible token transfer test transaction (ICS20 MsgTransfer)
    packet-recv         Relay receive or timeout packets
    packet-ack          Relay acknowledgment packets
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-1"><a class="header" href="#client-1">Client</a></h1>
<p>The <code>tx raw</code> commands can be used to create and update the on-chain IBC clients.</p>
<h2 id="table-of-contents-12"><a class="header" href="#table-of-contents-12">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/client.html#create-client">Create Client</a></li>
<li><a href="commands/raw/client.html#update-client">Update Client</a></li>
</ul>
<h2 id="create-client-1"><a class="header" href="#create-client-1">Create Client</a></h2>
<p>Use the <code>create-client</code> command to create a new client.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw create-client &lt;OPTIONS&gt;

DESCRIPTION:
    Create a client for source chain on destination chain

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain

</code></pre>
<p><strong>Example</strong></p>
<p>Create a new client of <code>ibc-1</code> on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw create-client ibc-0 ibc-1
</code></pre>
<pre><code class="language-json">{
    Success: CreateClient(
        CreateClient(
            Attributes {
                height: Height { revision: 0, height: 43 },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height { revision: 1, height: 32 },
            },
        ),
    )
}
</code></pre>
<p>A new client is created with identifier <code>07-tendermint-0</code></p>
<h2 id="update-client-1"><a class="header" href="#update-client-1">Update Client</a></h2>
<p>Use the <code>update-client</code> command to update an existing client with a new consensus state.
Specific update and trusted heights can be specified.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw update-client &lt;OPTIONS&gt;

DESCRIPTION:
    Update the specified client on destination chain

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    dst_client_id             identifier of the client to be updated on destination chain

FLAGS:
    -H, --target-height TARGET-HEIGHT
    -t, --trusted-height TRUSTED-HEIGHT
</code></pre>
<p><strong>Example</strong></p>
<p>Update the client on <code>ibc-0</code> with latest header of <code>ibc-1</code></p>
<pre><code class="language-shell">hermes tx raw update-client ibc-0 07-tendermint-0
</code></pre>
<pre><code class="language-json">Success: UpdateClient(
    UpdateClient {
        common: Attributes {
            height: Height { revision: 0, height: 110 },
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height { revision: 1, height: 109 },
        },
        header: Some(
            Tendermint(
                 Header {...},
            ),
        ),
    },
)
</code></pre>
<p>The client with identifier <code>07-tendermint-0</code> has been updated with the consensus state at height <code>1-273</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection-handshake"><a class="header" href="#connection-handshake">Connection Handshake</a></h1>
<p>The <code>tx raw</code> commands can be used to establish a connection between two clients.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No connection
    A-&gt;&gt;B: ConnectionOpenInit
    Note over B: connection: connection-0
    Note over B: counterparty: none
    B-&gt;&gt;A: ConnectionOpenTry
    Note over A: connection: connection-1
    Note over A: counterparty: connection-0
    A-&gt;&gt;B: ConnectionOpenAck
    note over B: connection: connection-0
    note over B: counterparty: connection-1
    B-&gt;&gt;A: ConnectionOpenConfirm
    Note over A, B: Connection open
</pre>
</center>
<h2 id="table-of-contents-13"><a class="header" href="#table-of-contents-13">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/connection.html#connection-init">Connection Init</a></li>
<li><a href="commands/raw/connection.html#connection-try">Connection Try</a></li>
<li><a href="commands/raw/connection.html#connection-ack">Connection Ack</a></li>
<li><a href="commands/raw/connection.html#connection-confirm">Connection Confirm</a></li>
</ul>
<h2 id="connection-init"><a class="header" href="#connection-init">Connection Init</a></h2>
<p>Use the <code>conn-init</code> command to initialize a new connection on a chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initialize a connection (ConnectionOpenInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client
</code></pre>
<p><strong>Example</strong></p>
<p>Given that two clients were previously created with identifier <code>07-tendermint-0</code> on chain <code>ibc-0</code> and
identifier <code>07-tendermint-1</code> on chain <code>ibc-1</code>, we can initialize a connection between the two clients.</p>
<p>First, let's initialize the connection on <code>ibc-0</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-1
</code></pre>
<pre><code class="language-json">Success: OpenInitConnection(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 73,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: None,
            counterparty_client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
        },
    ),
)
</code></pre>
<p>A new connection has been initialized on <code>ibc-0</code> with identifier <code>connection-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_connection_id</code> field is currently empty.</p>
</blockquote>
<h2 id="connection-try"><a class="header" href="#connection-try">Connection Try</a></h2>
<p>Use the <code>conn-try</code> command to establish a counterparty to the connection on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-try &lt;OPTIONS&gt;

DESCRIPTION:
    Relay the connection attempt (ConnectionOpenTry)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>connection-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw conn-try ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -s connection-0
</code></pre>
<pre><code class="language-json">Success: OpenTryConnection(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 88,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
</code></pre>
<p>A new connection has been created on <code>ibc-1</code> with identifier <code>connection-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> points to the connection on <code>ibc-0</code>.</p>
</blockquote>
<h2 id="connection-ack"><a class="header" href="#connection-ack">Connection Ack</a></h2>
<p>Use the <code>conn-ack</code> command to acknowledge the connection on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment of a connection attempt (ConnectionOpenAck)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -d, --dst-conn-id ID      identifier of the destination connection (required)
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the connection attempt:</p>
<pre><code class="language-shell">hermes tx raw conn-ack ibc-0 ibc-1 07-tendermint-0 07-tendermint-1 -d connection-0 -s connection-1
</code></pre>
<pre><code class="language-json">Success: OpenAckConnection(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 206,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
        },
    ),
)
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_connection_id</code> now points to the connection on <code>ibc-1</code>.</p>
</blockquote>
<h2 id="connection-confirm"><a class="header" href="#connection-confirm">Connection Confirm</a></h2>
<p>Use the <code>conn-confirm</code> command to confirm that the connection has been acknowledged,
and finish the handshake, after which the connection is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw conn-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm opening of a connection (ConnectionOpenConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_client_id             identifier of the destination client
    src_client_id             identifier of the source client

FLAGS:
    -d, --dst-conn-id ID      identifier of the destination connection (required)
    -s, --src-conn-id ID      identifier of the source connection (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the connection attempt.</p>
<pre><code class="language-shell">hermes tx raw conn-confirm ibc-1 ibc-0 07-tendermint-1 07-tendermint-0 -d connection-1 -s connection-0
</code></pre>
<pre><code class="language-json">Success: OpenConfirmConnection(
    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 239,
            },
            connection_id: Some(
                ConnectionId(
                    &quot;connection-1&quot;,
                ),
            ),
            client_id: ClientId(
                &quot;07-tendermint-1&quot;,
            ),
            counterparty_connection_id: Some(
                ConnectionId(
                    &quot;connection-0&quot;,
                ),
            ),
            counterparty_client_id: ClientId(
                &quot;07-tendermint-0&quot;,
            ),
        },
    ),
)
</code></pre>
<p>We have now successfully established a connection between the two chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-open-handshake"><a class="header" href="#channel-open-handshake">Channel Open Handshake</a></h1>
<p>The <code>tx raw</code> commands can be used to establish a channel for a given connection. Only <code>unordered</code> channels are currently supported.</p>
<center>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant A as ibc-1
    participant B as ibc-0
    Note over A, B: No channel
    A-&gt;&gt;B: ChannelOpenInit
    Note over B: channel: channel-0
    Note over B: channel: counterparty: none
    B-&gt;&gt;A: ChannelOpenTry
    Note over A: channel: channel-1
    Note over A: channel: counterparty: channel-0
    A-&gt;&gt;B: ChannelOpenAck
    note over B: channel: channel-0
    note over B: counterparty: channel-1
    B-&gt;&gt;A: ChannelOpenConfirm
    Note over A, B: Channel open
</pre>
</center>
<h2 id="table-of-contents-14"><a class="header" href="#table-of-contents-14">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/channel-open.html#channel-open-init">Channel Open Init</a></li>
<li><a href="commands/raw/channel-open.html#channel-open-try">Channel Open Try</a></li>
<li><a href="commands/raw/channel-open.html#channel-open-ack">Channel Open Ack</a></li>
<li><a href="commands/raw/channel-open.html#channel-open-confirm">Channel Open Confirm</a></li>
</ul>
<h2 id="channel-open-init"><a class="header" href="#channel-open-init">Channel Open Init</a></h2>
<p>Use the <code>chan-open-init</code> command to initialize a new channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initialize a channel (ChannelOpenInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -o, --order ORDER         the channel ordering, valid options 'unordered' (default) and 'ordered'
</code></pre>
<p><strong>Example</strong></p>
<p>First, let's initialize the channel on <code>ibc-0</code> using an existing connection identified by <code>connection-0</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-init ibc-0 ibc-1 connection-0 transfer transfer
</code></pre>
<pre><code class="language-json">Success: OpenInitChannel(
    OpenInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 3091
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: None,
        },
    ),
)
</code></pre>
<p>A new channel has been initialized on <code>ibc-1</code> with identifier <code>channel-0</code>.</p>
<blockquote>
<p>Note that the <code>counterparty_channel_id</code> field is currently empty.</p>
</blockquote>
<h2 id="channel-open-try"><a class="header" href="#channel-open-try">Channel Open Try</a></h2>
<p>Use the <code>chan-open-try</code> command to establish a counterparty to the channel on the other chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-try &lt;OPTIONS&gt;

DESCRIPTION:
    Relay the channel attempt (ChannelOpenTry)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Let's now create the counterparty to <code>channel-0</code> on chain <code>ibc-1</code>:</p>
<pre><code class="language-shell">hermes tx raw chan-open-try ibc-1 ibc-0 connection-1 transfer transfer -s channel-0
</code></pre>
<pre><code class="language-json">Success: OpenTryChannel(
    OpenTry(
        Attributes {
            height: Height {
                revision: 1,
                height: 3213
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<p>A new channel has been created on <code>ibc-1</code> with identifier <code>channel-1</code>.</p>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> points to the channel on <code>ibc-0</code>.</p>
</blockquote>
<h2 id="channel-open-ack"><a class="header" href="#channel-open-ack">Channel Open Ack</a></h2>
<p>Use the <code>chan-open-ack</code> command to acknowledge the channel on the initial chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment of a channel attempt (ChannelOpenAck)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>We can now acknowledge on <code>ibc-0</code> that <code>ibc-1</code> has accepted the opening of the channel:</p>
<pre><code class="language-shell">hermes tx raw chan-open-ack ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<pre><code class="language-json">Success: OpenAckChannel(
    OpenAck(
        Attributes {
            height: Height {
                revision: 0,
                height: 3301
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<blockquote>
<p>Note that the field <code>counterparty_channel_id</code> now points to the channel on <code>ibc-1</code>.</p>
</blockquote>
<h2 id="channel-open-confirm"><a class="header" href="#channel-open-confirm">Channel Open Confirm</a></h2>
<p>Use the <code>chan-open-confirm</code> command to confirm that the channel has been acknowledged,
and finish the handshake, after which the channel is open on both chains.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-open-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm opening of a channel (ChannelOpenConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<p>Confirm on <code>ibc-1</code> that <code>ibc-0</code> has accepted the opening of the channel,
after which the channel is open on both chains.</p>
<pre><code class="language-shell">hermes tx raw chan-open-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<pre><code class="language-json">    OpenConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 3483
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<p>We have now successfully opened a channel over an existing connection between the two chains.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-close-handshake"><a class="header" href="#channel-close-handshake">Channel Close Handshake</a></h1>
<p>The channel close handshake involves two steps: init and confirm.</p>
<h2 id="table-of-contents-15"><a class="header" href="#table-of-contents-15">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/channel-close.html#channel-close-init">Channel Close Init</a></li>
<li><a href="commands/raw/channel-close.html#channel-close-confirm">Channel Close Confirm</a></li>
</ul>
<h2 id="channel-close-init"><a class="header" href="#channel-close-init">Channel Close Init</a></h2>
<p>Use the <code>chan-close-init</code> command to initialize the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-close-init &lt;OPTIONS&gt;

DESCRIPTION:
    Initiate the closing of a channel (ChannelCloseInit)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx raw chan-close-init ibc-0 ibc-1 connection-0 transfer transfer -d channel-0 -s channel-1
</code></pre>
<pre><code class="language-json">Success: CloseInitChannel(
    CloseInit(
        Attributes {
            height: Height {
                revision: 0,
                height: 77,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-0&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<h2 id="channel-close-confirm"><a class="header" href="#channel-close-confirm">Channel Close Confirm</a></h2>
<p>Use the <code>chan-close-confirm</code> command to confirm the closure of a channel.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw chan-close-confirm &lt;OPTIONS&gt;

DESCRIPTION:
    Confirm the closing of a channel (ChannelCloseConfirm)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    dst_conn_id               identifier of the destination connection
    dst_port_id               identifier of the destination port
    src_port_id               identifier of the source port

FLAGS:
    -d, --dst-chan-id ID      identifier of the destination channel (required)
    -s, --src-chan-id ID      identifier of the source channel (required)
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="language-shell">hermes tx raw chan-close-confirm ibc-1 ibc-0 connection-1 transfer transfer -d channel-1 -s channel-0
</code></pre>
<pre><code class="language-json">Success: CloseConfirmChannel(
    CloseConfirm(
        Attributes {
            height: Height {
                revision: 1,
                height: 551,
            },
            port_id: PortId(
                &quot;transfer&quot;,
            ),
            channel_id: Some(
                ChannelId(
                    &quot;channel-1&quot;,
                ),
            ),
            connection_id: ConnectionId(
                &quot;connection-1&quot;,
            ),
            counterparty_port_id: PortId(
                &quot;transfer&quot;,
            ),
            counterparty_channel_id: Some(
                ChannelId(
                    &quot;channel-0&quot;,
                ),
            ),
        },
    ),
)
</code></pre>
<p><strong>NOTE</strong>: The <code>cosmos-sdk</code> transfer module implementation does not allow the user (<code>hermes</code> in this case) to initiate the closing of channels.
Therefore, when using the Gaia release image, the <code>chan-close-init</code> command
fails as the <code>MsgChannelCloseInit</code> message included in the transaction is rejected.
To be able to test channel closure, you need to <a href="commands/raw/../../help.html#patching-gaia">patch</a> your gaia deployments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-tx-commands"><a class="header" href="#packet-tx-commands">Packet Tx Commands</a></h1>
<h2 id="table-of-contents-16"><a class="header" href="#table-of-contents-16">Table of Contents</a></h2>
<ul>
<li><a href="commands/raw/packet.html#fungible-token-transfer">Fungible token transfer</a></li>
<li><a href="commands/raw/packet.html#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></li>
<li><a href="commands/raw/packet.html#relay-acknowledgment-packets">Relay acknowledgment packets</a></li>
</ul>
<h2 id="fungible-token-transfer"><a class="header" href="#fungible-token-transfer">Fungible token transfer</a></h2>
<p>Use the <code>tx raw ft-transfer</code> command to send ICS-20 fungible token transfer packets.
<strong>NOTE:</strong> This command is mainly used for testing the packet features of the relayer.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw ft-transfer &lt;OPTIONS&gt;

DESCRIPTION:
    Send a fungible token transfer test transaction (ICS20 MsgTransfer)

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
    amount                    amount of coins (samoleans, by default) to send (e.g. `100000`)

FLAGS:
    -o, --timeout-height-offset TIMEOUT-HEIGHT-OFFSET  timeout in number of blocks since current
    -t, --timeout-seconds TIMEOUT-SECONDS              timeout in seconds since current
    -r, --receiver RECEIVER                            receiving account address on the destination chain
    -d, --denom DENOM                                  denomination of the coins to send (default: samoleans)
    -n, --number-msgs NUMBER-MSGS                      number of messages to send
    -k, --key KEY                                      use the given signing key (default: `key_name` config)
</code></pre>
<p><strong>Example</strong></p>
<p>Send two transfer packets from the <code>transfer</code> module and <code>channel-0</code> of <code>ibc-0</code> to <code>ibc-1</code>. Each transfer if for <code>9999</code> samoleans (default denomination) and a timeout offset of <code>10</code> blocks. The transfer fee is paid by the relayer account on <code>ibc-1</code>.</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 -o 1000 -n 2
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 431,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
        },
    ),
]
</code></pre>
<p>The transfer packets are stored on <code>ibc-0</code> and can be relayed.</p>
<blockquote>
<p>To send transfer packets with a custom receiver address use the <code>--receiver | -r</code> flag.</p>
</blockquote>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-1 ibc-0 transfer channel-0 9999 -o 1000 -n 1 -r board:1938586739
</code></pre>
<pre><code class="language-json">Success: [
    SendPacket(
        SendPacket {
            height: Height {
                revision: 0,
                height: 546,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(7),
        },
    ),
]
</code></pre>
<h2 id="relay-receive-and-timeout-packets"><a class="header" href="#relay-receive-and-timeout-packets">Relay receive and timeout packets</a></h2>
<p>Use the <code>tx raw packet-recv</code> command to relay the packets sent but not yet received. If the sent packets have timed out then a timeout packet is sent to the source chain.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw packet-recv &lt;OPTIONS&gt;

DESCRIPTION:
    Relay receive or timeout packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
</code></pre>
<p><strong>Example</strong></p>
<p>Send the two transfer packets to the <code>ibc-1</code> module bound to the <code>transfer</code> port and the <code>channel-0</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the receive messages.</p>
<pre><code class="language-shell">hermes tx raw packet-recv ibc-1 ibc-0 transfer channel-0
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 1,
                    height: 439,
                },
                client_id: ClientId(
                    &quot;07-tendermint-1&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 0,
                    height: 449,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
    WriteAcknowledgement(
        WriteAcknowledgement {
            height: Height {
                revision: 1,
                height: 439,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
            ack: [
                123,
                34,
                114,
                101,
                115,
                117,
                108,
                116,
                34,
                58,
                34,
                65,
                81,
                61,
                61,
                34,
                125,
            ],
        },
    ),
]
</code></pre>
<p>Both packets have been relayed to <code>ibc-1</code> and acknowledged.</p>
<h2 id="relay-acknowledgment-packets"><a class="header" href="#relay-acknowledgment-packets">Relay acknowledgment packets</a></h2>
<p>Use the <code>tx raw packet-ack</code> command to relay acknowledgments to the original source of the packets.</p>
<pre><code class="language-shell">USAGE:
    hermes tx raw packet-ack &lt;OPTIONS&gt;

DESCRIPTION:
    Relay acknowledgment packets

POSITIONAL ARGUMENTS:
    dst_chain_id              identifier of the destination chain
    src_chain_id              identifier of the source chain
    src_port_id               identifier of the source port
    src_channel_id            identifier of the source channel
</code></pre>
<p><strong>Example</strong></p>
<p>Send the acknowledgments to the <code>ibc-0</code> module bound to the <code>transfer</code> port and the <code>channel-1</code>'s counterparty.</p>
<p><strong>NOTE</strong>: The relayer prepends a client update message before the acknowledgments.</p>
<pre><code class="language-shell">hermes tx raw packet-ack ibc-0 ibc-1 transfer channel-1
</code></pre>
<pre><code class="language-json">Success: [
    UpdateClient(
        UpdateClient {
            common: Attributes {
                height: Height {
                    revision: 0,
                    height: 495,
                },
                client_id: ClientId(
                    &quot;07-tendermint-0&quot;,
                ),
                client_type: Tendermint,
                consensus_height: Height {
                    revision: 1,
                    height: 483,
                },
            },
            header: Some(
                Tendermint(...),
            ),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(4),
        },
    ),
    AcknowledgePacket(
        AcknowledgePacket {
            height: Height {
                revision: 0,
                height: 495,
            },
            packet: PortId(&quot;transfer&quot;) ChannelId(&quot;channel-0&quot;) Sequence(5),
        },
    ),
]
</code></pre>
<p>Both acknowledgments have been received on <code>ibc-0</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>This section provides guidelines regarding troubleshooting and general
resources for getting help with <code>hermes</code>.
For this purpose, we recommend a few ideas that could be of help:</p>
<ul>
<li><a href="./help.html#help-command">hermes help</a> command, providing a CLI
documentation for all <code>hermes</code> commands.</li>
<li><a href="./help.html#profiling">profile</a> your relayer binary to identify slow methods;</li>
<li><a href="./help.html#parametrizing-the-log-output-level">configure</a> the <code>log_level</code> to help with debugging;</li>
<li><a href="./help.html#patching-gaia">patch</a> your local gaia chain(s) to enable some corner-case methods
(e.g., channel close);</li>
</ul>
<p>And if the above options do not address your specific problem:</p>
<ul>
<li>you can <a href="./help.html#new-feature-request">request a new feature</a>;</li>
<li>or consult the <a href="https://github.com/informalsystems/ibc-rs/issues">list of reported issues</a> and search by relevant
keywords to see if you're dealing with a known problem;</li>
<li>we would be grateful if you can submit a <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=bug-report.md">bug report</a>
discussing any problem you find, and from there on we can look at the
problem together;</li>
</ul>
<p>Lastly, for general questions, you can reach us at <code>hello@informal.systems</code>,
or on Twitter <a href="https://twitter.com/informalinc">@informalinc</a>.</p>
<h2 id="table-of-contents-17"><a class="header" href="#table-of-contents-17">Table of contents</a></h2>
<ul>
<li><a href="help.html#help-command">Help command</a></li>
<li><a href="help.html#parametrizing-the-log-output-level">Parametrizing the log output level</a></li>
<li><a href="help.html#inspecting-the-relayer-state">Inspecting the relayer state</a></li>
<li><a href="help.html#patching-gaia-to-support-chancloseinit">Patching <code>gaia</code> to support <code>ChanCloseInit</code></a></li>
<li><a href="help.html#new-feature-request">New Feature Request</a></li>
<li><a href="help.html#profiling">Profiling</a>
<ul>
<li><a href="help.html#setup">Setup</a></li>
<li><a href="help.html#example">Example</a>
<ul>
<li><a href="help.html#output">Output</a></li>
<li><a href="help.html#example-output-for-tx-raw-conn-init-command">Example output for <code>tx raw conn-init</code> command</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="help-command"><a class="header" href="#help-command">Help command</a></h2>
<p>The CLI comprises a special <code>help</code> command, which accepts as parameter other commands, and provides guidance on what is the correct way to invoke those commands.</p>
<p>For instance,</p>
<pre><code class="language-shell">hermes help create
</code></pre>
<p>will provide details about all the valid invocations of the <code>create</code> CLI command.</p>
<pre><code>USAGE:
    hermes create &lt;SUBCOMMAND&gt;

DESCRIPTION:
    Create objects (client, connection, or channel) on chains

SUBCOMMANDS:
    help       Get usage information
    client     Create a new IBC client
    connection Create a new connection between two chains
    channel    Create a new channel between two chains
</code></pre>
<p>This can provide further specific guidance if we add additional parameters, e.g., </p>
<pre><code class="language-shell">hermes help create channel
</code></pre>
<pre><code>USAGE:
    hermes create channel &lt;OPTIONS&gt;

DESCRIPTION:
    Create a new channel between two chains

POSITIONAL ARGUMENTS:
    chain_a_id                identifier of the side `a` chain for the new channel
    chain_b_id                identifier of the side `b` chain for the new channel (optional)

FLAGS:
    -c, --connection-a CONNECTION-A
    --port-a PORT-A           identifier of the side `a` port for the new channel
    --port-b PORT-B           identifier of the side `b` port for the new channel
    -o, --order ORDER         the channel ordering, valid options 'unordered' (default) and 'ordered'
    -v, --channel-version VERSION     the version for the new channel
</code></pre>
<p>Additionally, the <code>-h</code>/<code>--help</code> flags typical for CLI applications work on
all commands.</p>
<h2 id="parametrizing-the-log-output-level"><a class="header" href="#parametrizing-the-log-output-level">Parametrizing the log output level</a></h2>
<p>The relayer configuration file permits parametrization of output verbosity via the knob called <code>log_level</code>.
This file is loaded by default from <code>$HOME/.hermes/config.toml</code>, but can be overridden in all commands
with the <code>-c</code> flag, eg. <code>hermes -c ./path/to/my/config.toml some command</code>.</p>
<p>Relevant snippet:</p>
<pre><code class="language-toml">[global]
log_level = 'error'
</code></pre>
<p>Valid options for <code>log_level</code> are: 'error', 'warn', 'info', 'debug', 'trace'.
These levels correspond to the tracing sub-component of the relayer-cli,
<a href="https://docs.rs/tracing-core/0.1.17/tracing_core/struct.Level.html">see here</a>.</p>
<p>The relayer will <em>always</em> print a last line summarizing the result of its
operation for queries or transactions. In addition to this last line,
arbitrary debug, info, or other outputs may be produced.  Example, with
<code>log_level = 'debug'</code> and JSON output:</p>
<pre><code class="language-bash">{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.070&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;registered component: abscissa_core::terminal::component::Terminal (v0.5.2)&quot;},&quot;target&quot;:&quot;abscissa_core::component::registry&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.071&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;registered component: relayer_cli::components::Tracing (v0.0.6)&quot;},&quot;target&quot;:&quot;abscissa_core::component::registry&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.078&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;Options QueryClientConsensusOptions { client_id: ClientId(\&quot;07-tendermint-X\&quot;), revision_number: 0, revision_height: 1, height: 0, proof: true }&quot;},&quot;target&quot;:&quot;relayer_cli::commands::query::client&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.080&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;resolving host=\&quot;localhost\&quot;&quot;},&quot;target&quot;:&quot;hyper::client::connect::dns&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.083&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;connecting to [::1]:26657&quot;},&quot;target&quot;:&quot;hyper::client::connect::http&quot;}
{&quot;timestamp&quot;:&quot;Jan 20 19:21:52.083&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;fields&quot;:{&quot;message&quot;:&quot;connecting to 127.0.0.1:26657&quot;},&quot;target&quot;:&quot;hyper::client::connect::http&quot;}
{&quot;status&quot;:&quot;error&quot;,&quot;result&quot;:[&quot;query error: RPC error to endpoint tcp://localhost:26657: error trying to connect: tcp connect error: Connection refused (os error 61) (code: 0)&quot;]}
</code></pre>
<p>For the same command, with <code>log_level = 'error'</code>, just the last line will be
produced:</p>
<pre><code class="language-bash">{&quot;status&quot;:&quot;error&quot;,&quot;result&quot;:[&quot;query error: RPC error to endpoint tcp://localhost:26657: error trying to connect: tcp connect error: Connection refused (os error 61) (code: 0)&quot;]}
</code></pre>
<h2 id="inspecting-the-relayer-state"><a class="header" href="#inspecting-the-relayer-state">Inspecting the relayer state</a></h2>
<p>To get a little bit of insight into the state of the relayer,
Hermes will react to a <code>SIGUSR1</code> signal by dumping its state to
the console, either in plain text form or as a JSON object if Hermes
was started with the <code>--json</code> option.</p>
<p>To send a <code>SIGUSR1</code> signal to Hermes, look up its process ID (below PID)
and use the following command:</p>
<pre><code class="language-shell">kill -SIGUSR1 PID
</code></pre>
<p>Hermes will print some information about the workers which are currently running.</p>
<p>For example, with three chains configured and one channel between each pair of chains:</p>
<pre><code class="language-text">INFO Dumping state (triggered by SIGUSR1)
INFO
INFO * Chains: ibc-0, ibc-1, ibc-2
INFO * Client workers:
INFO   - client::ibc-0-&gt;ibc-1:07-tendermint-0 (id: 5)
INFO   - client::ibc-0-&gt;ibc-2:07-tendermint-0 (id: 9)
INFO   - client::ibc-1-&gt;ibc-0:07-tendermint-0 (id: 1)
INFO   - client::ibc-1-&gt;ibc-2:07-tendermint-1 (id: 11)
INFO   - client::ibc-2-&gt;ibc-0:07-tendermint-1 (id: 3)
INFO   - client::ibc-2-&gt;ibc-1:07-tendermint-1 (id: 7)
INFO * Packet workers:
INFO   - packet::channel-0/transfer:ibc-0-&gt;ibc-1 (id: 2)
INFO   - packet::channel-0/transfer:ibc-1-&gt;ibc-0 (id: 6)
INFO   - packet::channel-0/transfer:ibc-2-&gt;ibc-0 (id: 10)
INFO   - packet::channel-1/transfer:ibc-0-&gt;ibc-2 (id: 4)
INFO   - packet::channel-1/transfer:ibc-1-&gt;ibc-2 (id: 8)
INFO   - packet::channel-1/transfer:ibc-2-&gt;ibc-1 (id: 12)
</code></pre>
<p>or in JSON form (prettified):</p>
<pre><code class="language-json">{
  &quot;timestamp&quot;: &quot;Jul 12 17:04:37.244&quot;,
  &quot;level&quot;: &quot;INFO&quot;,
  &quot;fields&quot;: {
    &quot;message&quot;: &quot;Dumping state (triggered by SIGUSR1)&quot;
  }
}
{
  &quot;chains&quot;: [
    &quot;ibc-0&quot;,
    &quot;ibc-1&quot;,
    &quot;ibc-2&quot;
  ],
  &quot;workers&quot;: {
    &quot;Client&quot;: [
      {
        &quot;id&quot;: 5,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;
        }
      },
      {
        &quot;id&quot;: 9,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;
        }
      },
      {
        &quot;id&quot;: 1,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;
        }
      },
      {
        &quot;id&quot;: 11,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;
        }
      },
      {
        &quot;id&quot;: 3,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;
        }
      },
      {
        &quot;id&quot;: 7,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Client&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;dst_client_id&quot;: &quot;07-tendermint-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;
        }
      }
    ],
    &quot;Packet&quot;: [
      {
        &quot;id&quot;: 2,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_channel_id&quot;: &quot;channel-0&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 6,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_channel_id&quot;: &quot;channel-0&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 10,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_channel_id&quot;: &quot;channel-0&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 4,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-0&quot;,
          &quot;src_channel_id&quot;: &quot;channel-1&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 8,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_channel_id&quot;: &quot;channel-1&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      },
      {
        &quot;id&quot;: 12,
        &quot;object&quot;: {
          &quot;type&quot;: &quot;Packet&quot;,
          &quot;dst_chain_id&quot;: &quot;ibc-1&quot;,
          &quot;src_chain_id&quot;: &quot;ibc-2&quot;,
          &quot;src_channel_id&quot;: &quot;channel-1&quot;,
          &quot;src_port_id&quot;: &quot;transfer&quot;
        }
      }
    ]
  }
}
</code></pre>
<h2 id="patching-gaia-to-support-chancloseinit"><a class="header" href="#patching-gaia-to-support-chancloseinit">Patching <code>gaia</code> to support <code>ChanCloseInit</code></a></h2>
<p>The guide below refers specifically to patching your gaia chain so that the
relayer can initiate the closing of channels by submitting a <a href="./commands/raw/channel-close.html#channel-close-init"><code>ChanCloseInit</code></a> message.
Without this modification, the transaction will be rejected.
We also describe how to test the channel closing feature.</p>
<ul>
<li>
<p>Clone the Cosmos SDK</p>
<pre><code class="language-shell">git clone https://github.com/cosmos/cosmos-sdk.git ~/go/src/github.com/cosmos/cosmos-sdk
cd ~/go/src/github.com/cosmos/cosmos-sdk
</code></pre>
</li>
<li>
<p>Apply these diffs:</p>
<pre><code>   --- a/x/ibc/applications/transfer/module.go
   +++ b/x/ibc/applications/transfer/module.go
   @@ -305,7 +305,7 @@ func (am AppModule) OnChanCloseInit(
           channelID string,
    ) error {
           // Disallow user-initiated channel closing for transfer channels
   -       return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, &quot;user cannot close channel&quot;)
   +       return nil
    }
</code></pre>
</li>
<li>
<p>Append the line below (watch for the placeholder <code>&lt;your&gt;</code>) as the last line
in your <code>go.mod</code> in the gaia clone:</p>
</li>
</ul>
<p><code>replace github.com/cosmos/cosmos-sdk =&gt; /Users/&lt;your&gt;/go/src/github.com/cosmos/cosmos-sdk</code></p>
<ul>
<li>Now <code>make build</code> and <code>make install</code> your local copy of gaia</li>
</ul>
<p>In order to test the correct operation during the channel close, perform the steps below.</p>
<ul>
<li>
<p>the channel should be in state open-open:</p>
</li>
<li>
<p>transfer of 5555 samoleans from <code>ibc-1</code> to <code>ibc-0</code>. This results in a
Tx to <code>ibc-1</code> for a <code>MsgTransfer</code> packet.
Make sure you're not relaying this packet (the relayer should not be running on
this path).</p>
<pre><code class="language-shell">hermes tx raw ft-transfer ibc-0 ibc-1 transfer channel-1 5555 -o 1000 -n 1 -d samoleans
</code></pre>
</li>
<li>
<p>now do the first step of channel closing: the channel will transition
to close-open:</p>
<pre><code class="language-shell">hermes -c config.toml tx raw chan-close-init ibc-0 ibc-1 connection-0 transfer transfer channel-0 channel-1
</code></pre>
</li>
<li>
<p>trigger timeout on close to ibc-1</p>
<pre><code class="language-shell">hermes -c config.toml tx raw packet-recv ibc-0 ibc-1 transfer channel-1
</code></pre>
</li>
<li>
<p>close-close</p>
<pre><code class="language-shell">hermes -c config.toml tx raw chan-close-confirm ibc-1 ibc-0 connection-1 transfer transfer channel-1 channel-0
</code></pre>
</li>
<li>
<p>verify that the two ends are in Close state:</p>
<pre><code class="language-shell">hermes -c config.toml query channel end ibc-0 transfer channel-0
hermes -c config.toml query channel end ibc-1 transfer channel-1
</code></pre>
</li>
</ul>
<h2 id="new-feature-request"><a class="header" href="#new-feature-request">New Feature Request</a></h2>
<p>If you would like a feature to be added to <code>hermes</code>, don't hesitate
to open a discussion about that via the <a href="https://github.com/informalsystems/ibc-rs/issues/new?assignees=&amp;labels=&amp;template=feature-request.md">feature request</a>
issue template.</p>
<blockquote>
<p>Note that Hermes is packaged as part of the <code>ibc-relayer-cli</code> crate.</p>
</blockquote>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>The <code>relayer</code> crate provides a <code>time!</code> macro which can be used to measure how much time is spent between the invocation of the macro and the end of the enclosing scope.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>The <code>time!</code> macro has no effect unless the <code>profiling</code> feature of the <code>relayer</code> crate is enabled.</p>
<p>To enable it, one must compile the <code>relayer-cli</code> crate with the <code>--features=profiling</code> flag.</p>
<p>a) One way is to build the <code>relayer</code> binary and update the <code>hermes</code> alias to point to the executable:</p>
<pre><code class="language-shell">cd relayer-cli/
cargo build --features=profiling
</code></pre>
<p>b) Alternatively, one can use the <code>cargo run</code> command and update the alias accordingly:</p>
<pre><code class="language-shell">alias hermes='cargo run --features=profiling --manifest-path=relayer-cli/Cargo.toml --'
</code></pre>
<p>The <code>--manifest-path=relayer-cli/Cargo.toml</code> flag is needed for <code>cargo run</code> to accept the <code>--features</code> flag.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_function(x: u32) -&gt; u32 {
    time!(&quot;myfunction: x={}&quot;, x); // A

    std::thread::sleep(Duration::from_secs(1));

    {
        time!(&quot;inner operation&quot;); // B

        std::thread::sleep(Duration::from_secs(2));

        // timer B ends here
    }

    x + 1

    // timer A ends here
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="output"><a class="header" href="#output">Output</a></h4>
<pre><code>Jan 20 11:28:46.841  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - start
Jan 20 11:28:47.842  INFO relayer::macros::profiling:    ⏳ inner operation - start
Jan 20 11:28:49.846  INFO relayer::macros::profiling:    ⏳ inner operation - elapsed: 2004ms
Jan 20 11:28:49.847  INFO relayer::macros::profiling: ⏳ myfunction: x=42 - elapsed: 3005ms
</code></pre>
<p>Profiling is useful for tracking down unusually slow methods.
Each transaction or query usually consists of multiple lower-level methods,
and it's often not clear which of these are the culprit for low performance.
With profiling enabled, <code>hermes</code> will output timing information for individual
methods involved in a command.</p>
<p><strong>NOTE</strong>: To be able to see the profiling output, the realyer needs to be compiled with
the <code>profiling</code> feature and the <a href="./help.html#parametrizing-the-log-output-level">log level</a> should be <code>info</code> level or lower.</p>
<h4 id="example-output-for-tx-raw-conn-init-command"><a class="header" href="#example-output-for-tx-raw-conn-init-command">Example output for <code>tx raw conn-init</code> command</a></h4>
<pre><code>hermes -c   config.toml tx raw conn-init ibc-0 ibc-1 07-tendermint-0 07-tendermint-0
</code></pre>
<pre><code>Apr 13 20:58:21.225  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 4ms
Apr 13 20:58:21.230  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.235  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 5ms
Apr 13 20:58:21.235  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-1
Apr 13 20:58:21.236  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - start
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_light_client - elapsed: 2ms
Apr 13 20:58:21.239  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - start
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ init_event_monitor - elapsed: 4ms
Apr 13 20:58:21.244  INFO ibc_relayer::event::monitor: running listener chain.id=ibc-0
Apr 13 20:58:21.244  INFO ibc_relayer::macros::profiling: ⏳ get_signer - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ get_signer - elapsed: 1ms
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - start
Apr 13 20:58:21.246  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.248  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 1ms
Apr 13 20:58:21.249  INFO ibc_relayer::macros::profiling: ⏳ query_latest_height - elapsed: 3ms
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - start
Apr 13 20:58:21.250  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.251  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 0ms
Apr 13 20:58:21.270  INFO ibc_relayer::macros::profiling:    ⏳ block_on - start
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling:    ⏳ block_on - elapsed: 2ms
Apr 13 20:58:21.273  INFO ibc_relayer::macros::profiling: ⏳ unbonding_period - elapsed: 23ms
Apr 13 20:58:21.279  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ build_consensus_state - elapsed: 0ms
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - start
Apr 13 20:58:21.280  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:       ⏳ PK &quot;03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa&quot; - start
Apr 13 20:58:21.282  INFO ibc_relayer::macros::profiling:          ⏳ block_on - start
Apr 13 20:58:21.285  INFO ibc_relayer::macros::profiling:          ⏳ block_on - elapsed: 3ms
Apr 13 20:58:21.296  INFO ibc_relayer::macros::profiling:             ⏳ block_on - start
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:             ⏳ block_on - elapsed: 1367ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:       ⏳ PK &quot;03f17d2c094ee68cfcedb2c2f2b7dec6cd82ea158ac1c32d3de0ca8b288a3c8bfa&quot; - elapsed: 1382ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling:    ⏳ send_tx - elapsed: 1384ms
Apr 13 20:58:22.664  INFO ibc_relayer::macros::profiling: ⏳ send_msgs - elapsed: 1384ms
Success: CreateClient(
    CreateClient(
        Attributes {
            height: Height {
                revision: 0,
                height: 10675,
            },
            client_id: ClientId(
                &quot;07-tendermint-7&quot;,
            ),
            client_type: Tendermint,
            consensus_height: Height {
                revision: 1,
                height: 10663,
            },
        },
    ),
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>These are some of the definitions used in this guide: </p>
<table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody>
<tr><td>IBC transaction</td><td>A transaction that includes IBC datagrams (including packets). This is constructed by the relayer and sent over the physical network to a chain according to the chain rules. For example, for tendermint chains a broadcast_tx_commit request is sent to a tendermint RPC server.</td></tr>
<tr><td>IBC datagram</td><td>An element of the transaction payload sent by the relayer; it includes client, connection, channel and IBC packet data. Multiple IBC datagrams may be included in an IBC transaction.</td></tr>
<tr><td>IBC packet</td><td>A particular type of IBC datagram that includes the application packet and its commitment proof.</td></tr>
<tr><td>IBC Client</td><td>Client code running on chain, typically only the light client verification related functionality.</td></tr>
<tr><td>Relayer Light Client</td><td>Full light client functionality, including connecting to at least one provider (full node), storing and verifying headers, etc.</td></tr>
<tr><td>Source chain</td><td>The chain from which the relayer reads data to fill an IBC datagram.</td></tr>
<tr><td>Destination chain</td><td>The chain where the relayer submits transactions that include the IBC datagram.</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
